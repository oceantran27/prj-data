边界：
  矩阵的边界 以及邻近边界的格子是否计算

无解：
  无解时返回空或返回有一个空元素的vector
  是否允许返回为空（或者题目限定至少要有一个元素），根据需要返回0或者一个较差选择
  
输入：
  一开始就判掉 0, 1, 2的小情况 size = 0 的情况 和非法情况
  输入指针可以为NULL，或者指向一个长度0的字符串
  注意下标是从1开始还是从0开始
  是否可以有重复元素
  是否可以有0或负数
  
输出：
  不要忘了return
  输出的元素是否必须有序
  返回前删除所有new出来的临时空间
  
代码：
  声明指针的*紧邻变量 NodeList *p
  区分变量i, j的含义 遍历矩阵时明确 行，列相关变量 的表示（相关变量多时画在纸上）
  
指针：
  初始指针是否可以为空（或指向一个new出来的新节点）
  当p = p->next, 考虑p是否可能为空
  当从列表中删除元素，或修改元素时，考虑p是否可能失效，或者p->next失效
  当用临时指针保存某个点，用于修改后向下走时，注意这个点也可能在修改中被改动next域

搜索：
  注意入口点需要加入“visit”集合
  二分查找一个数组的子区间时，返回的是绝对下标还是相对下标
  返回 以及枚举时不合法continue 均要恢复现场
  
其他：
  开始是否需要排序
  当使用手写hash数组保存负数时，初始化必须加上deta
  尽量不要使用字符串末尾的 *s == 0 的trick化简代码。在所有需要的地方判断字符串长度。
  int变量考虑输入的n 或者 数组元素中是否可能为MAX_INT或者MIN_INT，
  考虑中间运算的加减法是否可能溢出， 考虑 *= -1 的时候是否溢出
  对容易混淆的计数 用for 代替while (cnt--)  对持续向后找的变量，用while代替for 防止忘记break
  考虑代表整数的字符串 是否会有前导0 以及前导0是否合法
  全局检查变量名串用或写错
  
问题相关
  括号匹配类问题都可以用栈解决
  
  
  
