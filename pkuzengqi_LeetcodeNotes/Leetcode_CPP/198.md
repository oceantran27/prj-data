
[https://leetcode.com/problems/house-robber/](https://leetcode.com/problems/house-robber/)

相关题：213

### 题目描述

这是一场有预谋的盗窃活动。现在一条路上有一排房间，每个房间都有一些钱。盗窃不能同时出现在两个相邻的房间，否则会触发警报。

现在给定这些房间的钱的数量，问在不触动警报的情况下最多能拿到多少钱。

#### 样例

```
Example 1:

Input: [1,2,3,1]
Output: 4
解释: 盗窃房间 1 (钱数 = 1) 然后盗窃房间 3 (钱数 = 3).
             盗窃的钱数总和 = 1 + 3 = 4.
             

Example 2:

Input: [2,7,9,3,1]
Output: 12
解释: 盗窃房间 1 (钱数 = 2), 盗窃房间 3 (钱数 = 9) 然后盗窃房间 5 (钱数 = 1).
             盗窃的钱数总和 = 2 + 9 + 1 = 12.
             
             
```


----------

### 算法
##### (动态规划)  $O(n)$

1. 令`f[i]`表示盗窃了第`i`个房间所能得到的最大收益，`g[i]`表示不盗窃第`i`个房间所能得到的最大收益。
2. `f[i] = g[i - 1] + nums[i]`，`g[i] = max(f[i - 1], g[i - 1])`。
3. 初始值`f[0] = nums[0], g[0] = 0`，答案为`max(f[n - 1], g[n - 1])`。

#### 优化
* 由于每次更新只用到了上一层的信息，故可以优化空间为常数。

#### 时间复杂度
* 状态数为$O(n)$，转移数为$O(1)$，转移时间为$O(1)$，故总时间复杂度为$O(n)$。


#### C++ 代码
```
// f[i]代表不盗窃第i个房间所能得到的最大收益， g[i]代表盗窃了第i个房间所能得到的最大收益
// f[i]的更新：上一个偷不偷都行，反正这个不偷
// g[i]的更新：上一个不偷，加上现在这个

class Solution {
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(!n) return 0;
        
        int f=nums[0], g=0;
        for(int i=1;i<n;++i){
            int last_f=f, last_g=g;
            f=g+nums[i];
            g=max(last_f, last_g);
        }
        return max(f,g);
    }
};
```



