# LeetCode 一句话题解 - 1001-1500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 1001-1500](#leetcode-一句话题解---1001-1500)
  - [1001 - 1100](#1001---1100)
  - [1101 - 1200](#1101---1200)
  - [1201 - 1300](#1201---1300)
  - [1301 - 1400](#1301---1400)
  - [1401 - 1500](#1401---1500)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1001-1500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1001-1500)

## 1001 - 1100

1002 Find Common Characters

题意：给定一个词表words，请统计在所有单词中都出现的字母，<b>顺序任意</b>。返回结果<b>包括字母种类和个数</b>，可以是多个。

难度：easy

解法：<b>哈希计数</b>，取min即可。

<hr>

1003 Check If Word Is Valid After Substitutions

题意：我们定义<b>一种操作</b>，在一个字符串的<b>任意位置</b>，插入“abc”。给定字符串s，请判断能否<b>从空串“”开始</b>，经过若干次操作得到s？

难度：medium

解法：乍一看，可能会想类似`dp[i][j]`的思路。其实仔细想想，这是个<b>栈操作</b>。比如“aabcbc”，那么当我<b>攒够一个abc</b>，我就可以把它<b>出栈</b>了。`[a,a,b,c]->[a]`，继续入栈bc，得到`[a,b,c]->[]`。按照这个思路，用一个栈处理整个字符串，如果最后能<b>清空整个栈</b>，则序列有效。奇怪的是，我以前的代码直接用的<b>暴力解法</b>，也过了。

<hr>

1004 Max Consecutive Ones III

题意：485的变体。给定01数组nums，如果你至多可以反转k个0，请问能得到的<b>最长连续1的个数</b>是多少？

难度：medium

解法：这题有两种思维，一种是想办法找出<b>应该反转0的位置</b>。这种很难，做不出来。另一种是找出一个窗口，使得窗口尽量长，且<b>窗口里有至多k个0</b>。你看，<b>滑动窗口</b>的思路就有了。这个滑动窗口<b>连dict都不需要</b>，因为我们只关心0的个数。

<hr>

1005 Maximize Sum Of Array After K Negations

题意：给定数组nums，你必须执行<b>k次操作</b>，每次任选一个元素乘以-1。请返回<b>最大的数组和</b>。

难度：easy

解法：根据<b>负数的个数</b>，分情况讨论。因为可以重复选同一个元素，那么<b>如果k很大</b>，我们可以浪费2m次操作，剩下k-2m次则用于<b>把负数变正</b>。

<hr>

1006 Clumsy Factorial

题意：阶乘知道吧？我们定义一种<b>奇怪的阶乘</b>`clumsy(n)=n*(n-1)/(n-2)+(n-3)-(n-4)*...`。但是这个式子依然按<b>正常的+-*/优先级</b>执行，除法以<b>整除</b>为准。给定n，请求出clumsy(n)的值。

难度：medium

解法：`a/b*c`、`+d-`，按照这两部分做<b>结合</b>。数据规模也不大，就这样<b>3131分组</b>，进行计算就行了。

<hr>

1007 Minimum Domino Rotations For Equal Row

题意：给定等长的数组tops、bottoms。每次允许你<b>任选位置i</b>，将`tops[i]`和`bottoms[i]`交换。请判断是否可能让tops或者bottoms变成<b>同一个值</b>。

难度：medium

解法：可以反过来想。如果能做到，则表示<b>某个值x</b>在<b>所有tops[i]或bottoms[i]都出现了</b>。因此，用哈希表记录每个值出现的位置。如果某值x出现在n个位置，则符合要求。对于<b>最小交换次数</b>，则考虑这个x所处的位置，<b>在tops居多，还是bottoms居多</b>。

<hr>

1008 Construct Binary Search Tree from Preorder Traversal

题意：给定前序遍历，请重建出一棵<b>二叉搜索树</b>。

难度：medium

解法：BST的中序遍历是有序的，因此你相当于有了<b>前序和中序</b>。剩下不说了。

<hr>

1009 Complement of Base 10 Integer

题意：给定整数n，请将其二进制表示进行01反转。

难度：easy

解法：水题。

<hr>

1010 Pairs of Songs With Total Durations Divisible by 60

题意：给定数组times，请找出其中`(times[i]+times[j])%60==0`的`(i,j)`对数。

难度：medium

解法：用哈希表，进行前缀计数。如果当前元素`times[i]%60==r`，则统计之前余数为`60-r`的个数。总代价O(n)。

<hr>

1011 Capacity To Ship Packages Within D Days

题意：有n件货物，重量为weigts[i]。如果每天运输的货物总量不能超过limit，且你需要在days天内，<b>按weights的顺序</b>运完。请问<b>limit最小值</b>是多少？

难度：medium

解法：首先，这个问题有<b>单调性</b>。因此可以用二分搜索limit的值，那么判断依据怎么定？判断依据应该是limit取某值x时，能否在days天完成运输。实际上，本题的关键在于“按weights的顺序”。<b>如果可以乱序</b>，这个问题就成了<b>背包问题</b>，那就难了。要求按weight顺序的话，<b>每次判断运送天数</b>，就很容易，可以用O(n)代价完成。这样，总代价就是O(nlog(int))。

<hr>

1013 Partition Array Into Three Parts With Equal Sum

题意：给定数组nums，请判断能否划分为<b>左中右三段</b>，使得三段的<b>子数组和都相等</b>。

难度：easy

解法：对于easy题，这题还是<b>稍难</b>的。我们<b>枚举j维度</b>，则`nums[j:n]`这段<b>后缀和</b>我们可以O(1)获取，比如值为sm。则我们在前缀`nums[0:j]`里，判断是否存在某个前缀和`nums[0:i]`等于sm。如果存在，且中段`nums[i:j]`恰好也等于sm，则<b>三等分</b>就找到了。这些<b>前缀、后缀和</b>都需要O(n)代价进行<b>预处理</b>，处理之后就可以O(1)查询了。枚举j维度代价是<b>O(n)</b>，每个位置的判断代价为<b>O(1)</b>，因此总代价是O(n)。

<hr>

1014 Best Sightseeing Pair

题意：给定数组nums，任选选取两个位置`i<j`，则得分为`nums[i]+nums[j]+i-j`。请求出<b>最大得分</b>。

难度：medium

解法：O(n^2)枚举的做法很简单，需要想想<b>优化</b>办法。一种方法是对数组先按值排序，然后直接<b>暴力枚举</b>。但是枚举时，可以加一点检查，<b>让循环尽早结束</b>。除此之外，想不出很高效的解法。看到评论区，有人说可以理解为`(nums[i]+i)+(nums[j]-j)`，这样就简单了。<b>确实。</b>

<hr>

1015 Smallest Integer Divisible by K

题意：给定正整数k，请求出一个最小的n位数，使得所有数位都是1，且这个数<b>被k整除</b>。返回n，如果不存在则返回-1。

难度：medium

解法：其实你可以理解为<b>余数</b>。比如从1开始，1、10、100、...每个<b>都对k取模</b>。这样我会得到一个余数序列，且这个序列<b>一定是循环的</b>。那么我可以按这个方式，进行<b>累加</b>。如果发现余数求和的序列，<b>能到达0</b>，则可以得出最小的n值。因为余数求和序列也<b>一定是循环的</b>，如果循环节不包括0，则表示这个数<b>永远不会被k整除</b>。

<hr>

1016 Binary String With Substrings Representing 1 To N

题意：给定01字符串s和一个整数n。请判断对于<b>`[1,n]`的所有数</b>，是否可以在s中找到它们的二进制表示。

难度：medium

解法：观察<b>数据范围</b>，可以发现n很大，但<b>s的长度不大</b>。那么我们可以枚举所有s的子串，并统计对应的整数值。检查统计结果是否<b>覆盖了`[1,n]`所有值</b>。这基本就是<b>暴力解法</b>了，但至少对于s的长度，是<b>可接受的</b>。看了下当年代码，我似乎写了个更暴力的解法，<b>竟然还过了</b>。

<hr>

1017 Convert to Base -2

题意：给定整数n，请转换为<b>-2进制</b>。

难度：medium

解法：<b>负数进制</b>，有意思。其实<b>千万不要想复杂</b>，还是按常规的<b>进制转换</b>的做法，<b>模r除r</b>，只不过这次`r=-2`。就这么简单。

<hr>

1018 Binary Prefix Divisible By 5

题意：给定01数组nums，我们用xi表示`nums[0:i+1]`构成的<b>二进制数</b>的值。请返回所有<b>xi被5整除</b>的对应位置i。

难度：easy

解法：水题。

<hr>

1019 Next Greater Node In Linked List

题意：给定单链表，对于每个节点，请找出它之后，<b>第一个大于它的值</b>。如果没有更大值，则按0处理。

难度：medium

解法：不论数组还是链表，其实无所谓。用一个<b>单调栈（或队列也行）</b>，可以处理这个问题。这个栈<b>单调递减</b>，比如当前元素是x，那么如果栈顶元素`y<x`，则表示<b>y的next greater</b>找到了。这时让y<b>出栈</b>。持续出栈，直到栈顶`y>=x`为止，这时<b>把x入栈</b>。按照这个逻辑，最后<b>留在栈中</b>的值，<b>都不存在next greater</b>，结果都按0处理。

<hr>

1020 Number of Enclaves

题意：给定m x n地形，0水1陆地。从任意陆地出发，可以按4邻接方向移动到<b>另一陆地或者出界</b>。请统计所有陆地格子中，<b>不能走出界</b>的个数。

难度：medium

解法：用<b>洪泛算法</b>，搜索<b>不和边界格子连通</b>的陆地个数。或者反过来想，从<b>边界的陆地</b>开始搜索。那么剩下<b>没有被搜到的个数</b>，就是答案。

<hr>

1021 Remove Outermost Parentheses

题意：给定一个<b>匹配的括号序列s</b>，如果找不出`s1+s2=s`，使得s1、s2都是匹配序列，则称s是一个<b>原始串</b>。现在给定s，将它划分为几个原始子串，并去掉每个子串的<b>最外层括号</b>。返回去掉后的剩余结果。

难度：easy

解法：题目讲得挺复杂，思路倒是不难。用一个栈进行模拟，<b>“(”入栈，“)”出栈</b>。当栈<b>恰好清空</b>，证明你找到了一个<b>原始串</b>，记录下对应的<b>左右边界</b>，把<b>边界的“(”和“)”</b>去掉即可。

<hr>

1022 Sum of Root To Leaf Binary Numbers

题意：给定二叉树，节点值都是0或1。从根到叶组成的路径表示一个<b>二进制数</b>。请求出所有<b>路径之和</b>。

难度：easy

解法：按题意，递归求和即可。

<hr>

1023 Camelcase Matching

题意：<b>驼峰命名法</b>，比如“HelloWorld”，HW大写。现在给定一个词表queries和一个模式串。请判断单词里的<b>大写字符</b>是否符合<b>给定模式</b>。符合的标准是，给定单词w和模式p，你可以在p中<b>插入小写字符</b>，<b>使其变为w</b>。

难度：medium

解法：其实就是<b>判断子序列</b>。但判断过程中，如果发现单词里的<b>大写字符没有匹配</b>，则不符合要求。因为你<b>只能插入小写字符</b>，大写必须全部匹配。

<hr>

1024 Video Stitching

题意：给定一些`[x,y]`形式的区间clips，请从其中选出最少的区间，使得拼起来能<b>完整覆盖`[0,t]`范围</b>。返回选出的<b>区间个数</b>。

难度：medium

解法：首先按`(x,y)`维度<b>排序</b>。接下里，O(n^2)的DP思路很容易想到了。对于`clips[i]`，枚举`0~i-1`，看是否满足`clips[j].y>=clips[i]`，如果满足，则`dp[i]=min(dp[i],dp[j]+1)`。我们只关心<b>最少用dp[i]步</b>能到达i位置。最后检查结果时，判断两个条件：<b>i位置</b>是否能到达，<b>右边界t</b>是否能覆盖`clips[i].y>=t`。那么<b>左边界0</b>怎么确定呢？左边界在DP计算时，已经确定过了。

<hr>

1025 Divisor Game

题意：给定整数n，玩一种游戏。两人轮流选一个<b>n的约数x，且x<n</b>，n变为<b>n-x</b>。如果一方<b>无法找到x</b>，则输掉游戏。请判断<b>先手</b>是否必胜？

难度：easy

解法：还是按照博弈的<b>基本思路</b>：定义<b>一步状态转移</b>关系`x->y`，如果<b>所有</b>y都输，则x输；如果<b>存在某个</b>y能赢，则选这条赢的路，x赢。照这个思路，搜索所有状态转移，用<b>DP思路</b>可以解决。对于一道easy题，这已经很难了。

<hr>

1026 Maximum Difference Between Node and Ancestor

题意：给定二叉树，请求出其中两节点a、b的<b>最大差值`|a.val-b.val|`</b>，且a是b的祖先节点。注意，是<b>祖先节点</b>，不一定是父节点。

难度：medium

解法：因为是祖先节点，我可以往下看。对于任何点p，p所在子树总有个<b>最小值、最大值</b>。那么我用`max_val`、`min_val`表示。则这个<b>子树之内</b>，答案只能是`|p.val-max_val|`、`|p.val-min_val|`其中之一。按这个思路，遍历整棵树即可。

<hr>

1027 Longest Arithmetic Subsequence

题意：给定数组nums，求出最长的<b>算术子序列</b>长度。算术意思是<b>等差数列</b>。

难度：medium

解法：很明显的<b>DP思路</b>，枚举两个维度`j<i`，则公差`d=nums[i]-nums[j]`。我可以用`dp[(i,d)]`表示以i位置为<b>终点</b>，公差为d的<b>等差数列的长度</b>。实际上dp数组的类型是`list[dict[int,int]]`，细节就不说了。为什么<b>倒推</b>，而不用正推呢？因为i之后的值，<b>你还不知道</b>，无法<b>复用子问题的结果</b>，这不符合DP的思维。

<hr>

1028 Recover a Tree From Preorder Traversal

题意：给定一种特殊的前序遍历。对于节点p，如果它深度为d，则输出d个`-`，再输出`p.val`。根节点的深度为0。如果节点只有<b>1个子节点</b>，则一定是<b>左节点</b>。按照这个遍历结果的字符串，重建整棵树。

难度：hard

解法：首先当然是字符串处理，解析成`[(深度,节点值)]`的格式。既然是前序遍历，那我们从深度变化，来判断是往下还是往上。比如`1-2--3--4-5--6--7`，处理后对应`[(0,1),(1,2),(2,3),(2,4),(1,5),(2,6),(2,7)]`。那么我们从i=0开始，根据i+1位置的深度，来判断我应该往下<b>1层</b>，还是往上<b>1或几层</b>。至于<b>左右节点</b>，如果左子树已经遍历了，就往右；否则，先创建左子树。总体上，不算特别难，但需要一点<b>脑力+体力</b>的一题。

<hr>

1029 Two City Scheduling

题意：有2n个人，每个人前往a城、b城的代价，分别是`costs[i]=[ai,bi]`。现在需要各n人前往两个城市，请求出<b>最小的总代价</b>。

难度：medium

解法：其实这题有点<b>脑筋急转弯</b>。如果你按<b>DP思路</b>做，也可以，但很复杂。我们考虑选出了n人去a城，n人去b城，则可以理解为`sum(所有a[i])-sum(没被选中的a[j])+sum(对应被选中的b[j])`。这其中`sum(a[i])`是固定值，因此我们尽可能让`sum(没被选中的a[j]-b[j])`<b>最大</b>，则总代价就<b>最小</b>。于是，你按a[i]-b[i]排序，选出<b>后n个值</b>，就是最大值了。对后n个，我们<b>取b城</b>；前n个，则<b>取a城</b>。代码非常简单，但思维并不容易。<b>有点坑人。</b>

<hr>

1030 Matrix Cells in Distance Order

题意：给定<b>行数列数n、m</b>，以及中心点`(r0,c0)`。请按照距离<b>从近到远</b>，给n*m个坐标排序。距离以Manhattan距离`|x1-x2|+|y1-y2|`为准。

难度：easy

解法：按题意实现即可，<b>排序</b>。

<hr>

1031 Maximum Sum of Two Non-Overlapping Subarrays

题意：给定数组nums和长度n1、n2。请在其中找出两个长度为n1、n2的<b>不重叠子数组</b>，使得<b>子数组和加起来</b>最大。

难度：medium

解法：按照<b>前缀max、后缀max</b>的方式，求出每个i位置的<b>子数组最大和</b>。针对n1、n2都求一次。然后按照<b>n1左n2右、n2左n1右</b>的方式求出最大值。思路不难，写起来还挺麻烦的。

<hr>

1033 Moving Stones Until Consecutive

题意：有三颗石头，位于`a<b<c`三个位置。每次操作，你可以选左右端点的一个，把石头移动到k位置，且满足`a<k<c,k!=b`。这个步骤必然会缩小范围，如果最终<b>abc挨在一起</b>，则操作结束。请求出你能执行的最大、最小操作次数。

难度：medium

解法：最大次数简单，我每次只移动一格，而且区间长度也至少-1。那我就每次-1，答案是`c-a-2`。<b>最小次数</b>，要想一下。比如abc，我拿a，则我肯定应该把a放到bc中间，这样就成了bac。为什么？因为这样我直接<b>消灭了一个区间</b>。因此，每次我都<b>消灭更长的区间</b>，也就是`max(ab,bc)`。其实<b>至多2次就能搞定</b>，想想为什么？这题总体上是个<b>智力题</b>。

<hr>

1034 Coloring A Border

题意：给定m x n矩阵grid，`grid[i][j]`的值表示颜色，想通颜色的4邻接格子组成一个<b>连通分量</b>。现在给定位置`(r,c)`，请将对应的连通分量的<b>边界</b>改为color颜色。

难度：medium

解法：洪泛算法，从`(r,c)`出发，<b>执行BFS</b>并且找出边界，修改值为color即可。

<hr>

1035 Uncrossed Lines

题意：给定数组nums1和nums2，你可以选定`nums1[i]`和`nums2[j]`连一条线，如果<b>两者的值相等</b>。每个元素不能发出<b>超过一条线</b>，且要求所有线不能<b>交叉</b>。请问至多能连几条线。

难度：medium

解法：重点是线不能<b>交叉</b>。也就是说，对于上一条线`(i1,j1)`，我们的下一条线`(i2,j2)`必须满足`i1<i2,j1<j2`。<b>贪心还是DP？</b>应该是<b>DP</b>。我们定义`dp[i][j]`表示`nums1[0:i+1]`和`nums2[0:j+1]`部分<b>最多能连线</b>的个数。剩下不用说了，这其实就是最长公共子序列，<b>LCS问题</b>。

<hr>

1037 Valid Boomerang

题意：给定三个点，判断是否<b>不共线</b>。

难度：easy

解法：水题。

<hr>

1038 Binary Search Tree to Greater Sum Tree

题意：把一个BST转化为<b>“较大树”</b>。意思是，每个节点的值都变为<b>本身+所有大于它的值之和</b>。

难度：medium

解法：有个<b>土办法</b>，就是做<b>中序遍历</b>。把节点都<b>放到数组里</b>，进行后缀累加。

<hr>

1039 Minimum Score Triangulation of Polygon

题意：<b>多边形</b>的<b>三角剖分</b>是图形学里的一种基本操作。给定n个顶点的<b>凸多边形</b>，每个点有个分值`values[i]`。现在需要将其划分为n-2个三角形，每个三角形的点都从n个点选取，且不存在<b>交叉边</b>。对于每个三角形，分值按照<b>三顶点分值`values[i]`的乘积</b>计算。总分是所有三角的<b>分值之和</b>。请求出最小总分。

难度：medium

解法：如果不知道这个概念，从<b>几何上</b>确实挺难理解。最好<b>用草稿纸画一下</b>。其实这题难点在于<b>怎么划分子问题</b>。比如我选了ijk三个点，分<b>三种情况</b>讨论。比如ijk相邻，则剩余的i~k是<b>一个子问题</b>；比如ij相邻，k不相邻，则剩余的i~k、j~k是<b>两个子问题</b>；比如ijk都不相邻，则剩余的i~j、j~k、k~i是<b>三个子问题</b>。n变形，这相当于一个<b>环形数组</b>。因此你用dp[i][j]表示子问题时，要注意i<=j、i>j的情况，两者其实是<b>对称的</b>。剩下的DP细节就不说了。<b>有难度</b>的一题，需要一点<b>几何思维</b>才能搞明白。对于每个dp[i][j]，需要枚举中间的k得到最优解，因此总代价是<b>O(n^3)</b>。用<b>三层循环</b>或者<b>记忆化搜索</b>都可以。

<hr>

1040 Moving Stones Until Consecutive II

题意：1033的变体。这次有<b>n个石头</b>，其他规则完全相同。返回最大、最小移动次数。

难度：medium

解法：既然1033题已经做了，而且是个<b>智力题</b>，那这次尝试用<b>相同思维</b>。游戏结束的条件是，n个石头完全<b>挨在一起</b>。<b>最大次数</b>，还是按照每次距离-1，这个总是可以办到的，和1033一样。最小次数，则可以考虑枚举两个位置i、j，但i、j距离<b>至少应该是n-1</b>，这样才能<b>容纳n个石头</b>。剩下工作，就是把(i,j)范围之外的石头<b>都搬进来</b>了。<b>这题挺难的。</b>

<hr>

1041 Robot Bounded In Circle

题意：机器人开始在`(0,0)`位置，朝向+y方向。三种命令，G前进1格、L左转、R右转。如果给定一个<b>指令序列s</b>，机器人不断<b>重复执行</b>这个序列。请判断机器人的路径是否构成一个<b>环路</b>。

难度：medium

解法：其实是个<b>智力题</b>，很坑爹的那种。我们只执行一次s，如果发现<b>方向变了</b>，则<b>一定会循环</b>。<b>仔细想想</b>为什么。如果方向不变，则判断发生的总位移`(x,y)`是否为0，<b>不为0则不循环</b>。其实<b>循环的逻辑</b>不难想，如果你转了<b>180度</b>，`(+x,+y)`就变成了`(-x,-y)`，两次回原点；如果你转了<b>90度</b>，则依次按照`(+x,+y),(+y,-x),(-x,-y),(-y,+x)`，四次回原点。总之，一定会循环的。

<hr>

1042 Flower Planting With No Adjacent

题意：n个节点的<b>无向图</b>，存在一些边`[x,y]`。已知每个点的度数不超过3。你可以用4种颜色给n个点着色，使得任意<b>两个相邻的点</b>不同色。请返回一种有效的<b>着色方案</b>。

难度：medium

解法：这就是著名的<b>四色定理</b>，讲的是地图上相邻的地块，最多用四种颜色就可以保证相邻颜色不冲突了。当然，<b>证明四色定理</b>曾经是一个<b>世界级难题</b>，但给出一个着色方案不算很难。直接<b>搜索+回溯</b>即可。因为颜色总数为4，且每个点的度数不超过3，即使失败了，<b>回溯的代价</b>也<b>不会很大</b>。看来这题曾经的难度是easy，后来改medium了。<b>这肯定不是easy。</b>

<hr>

1043 Partition Array for Maximum Sum

题意：给定数组arr，请将其划分为长度至多为k的子数组。定义每个子数组的得分为`max(sub)*len(sub)`，也就是<b>最大值乘以长度</b>。请求出<b>子数组得分总和的最大值</b>。

难度：medium

解法：DP的思路还是很容易看出的。对于arr[0:i+1]，我可以看看划分出几段。比如我从arr[j:i+1]划分一段，当然这个长度不能超过k。那么`dp[i]=max(dp[j]+max(arr[j:i+1])*(i-j+1))`。这样的话，总代价O(n^2)，答案就是`dp[n-1]`。在这里面，求`max(arr[j:i+1])`的操作，也可以通过<b>预计算</b>来提高效率，<b>预计算代价`O(n^2)`</b>，之后O(1)可查。

<hr>

1046 Last Stone Weight

题意：有n个石头，大小用`stones[i]`表示。每次选出最大的两个石头x、y。如果`x!=y`，则碰撞后剩余石头`|x-y|`；如果相等，则两个石头都消失。请求出<b>最终剩余石头</b>的大小。

难度：easy

解法：<b>最大堆</b>，每次取出两个元素。

<hr>

1047 Remove All Adjacent Duplicates In String

题意：给定字符串s，如果其中存在两个<b>相邻的相等字符</b>`s[i]==s[i+1]`，则<b>都移除</b>。持续移除，直到没有相邻的相等字符为止，返回最终结果。

难度：easy

解法：用<b>栈</b>。

<hr>

1048 Longest String Chain

题意：给定一个词表words，请从中选出一些词`w[i]`，使得每个`w[i]`都是`w[i+1]`的子序列，称为一个<b>“词链”</b>。请求出词链的<b>最大长度</b>。

难度：medium

解法：题目定义了一个predecessor概念，其实就是<b>子序列</b>。首先应该按<b>长度降序</b>进行排序。从0位置开始，定义`dp[i]`为以<b>i位置开始</b>的<b>最长词链长度</b>。则枚举`j=0~i-1`，如果`words[j]`是`words[i]`的子序列，则`dp[i]=max(dp[i],dp[j]+1)`，必须<b>按长度排序</b>，这个枚举方式才有效。看了下当年的代码，<b>写法略有不同</b>，但思路差不多。

<hr>

1049 Last Stone Weight II

题意：1046的变体。这次可以<b>任选两个石头碰撞</b>，不用选最大的两个。这次希望最后剩下的石头最小，或者全部消失。请求出最终剩下的<b>最小石头</b>的尺寸。

难度：medium

解法：想了下，<b>没什么好思路</b>。也不能<b>暴力搜</b>吧？其实有个思路，比如l<b>两个石头</b>`x>y`，碰撞后剩下的是`x-y`。如果我有<b>两堆石头</b>，<b>总量</b>分别是x和y呢？其实<b>可以证明</b>，碰撞后剩下的碎石头，总量也是`x-y`。明白这点，就可以转化为<b>01背包问题</b>了。怎么才能让最终剩余的石头最少？我将石头分为两堆，使得两堆的差值最小即可。因此，对于总和sum，我可以用<b>01背包</b>的解法，求出我能得到的最接近`sum/2`的值。剩下不说了。

<hr>

1051 Height Checker

题意：给定数组a，请比较`a`和`sorted(a)`<b>值不相等</b>的位置个数。

难度：easy

解法：水题。

<hr>

1052 Grumpy Bookstore Owner

题意：给定n分钟，每分钟有`customers[i]`个客人进店。grumpy[i]表示第i分钟的<b>怒气值</b>，0则表示客人<b>满意</b>，1不满意。如果允许你选择其中的<b>连续k分钟</b>，让怒气保持0。请求出最大的<b>满意客人个数</b>。

难度：medium

解法：题目讲得挺复杂，其实只考虑这k分钟就行。首先，我们对<b>所有`grumpy[i]==0`的位置</b>，求customers[i]之和，这个作为一个固定值。然后考虑所有长度为k个窗口，计算每个窗口里，因`grumpy[i]==1`而损失的客人。这个窗口是<b>滑动窗口</b>，且窗口大小<b>固定是k</b>，因此计算很容易，用<b>前缀和相减</b>即可。求出所有窗口中，<b>损失最大</b>的一个。我们挽回这个<b>最大损失</b>，就可以使<b>最多的顾客</b>满意了。总代价<b>O(n)</b>。

<hr>

1053 Previous Permutation With One Swap

题意：给定可能有重复元素的数组arr，请通过<b>一次交换</b>，得到字典序小于arr的最大数组。如果不存在，则返回原数组。

难度：medium

解法：一次交换，要求<b>largest smaller</b>。那么我们应该把交换尽量放在尾巴上。我们看个例子，`[1,6,3,5,7]`，那么357已经顺序，不可能更小，因此我<b>需要交换6</b>。6和谁换？应该和467里，<b>小于6且最大</b>的换，因此是`[1,5,3,6,7]`。总结思路，找出<b>第一个逆序元素</b>`a[i]>a[i+1]`，再从`[i+1,n-1]`里，找出<b>最后一个j</b>，使得`a[j]<a[i]`，交换`(a[i],a[j])`就是答案。总代价<b>O(n)</b>。

<hr>

1054 Distant Barcodes

题意：给定数组arr，请重排顺序，使得任意相邻元素都不相等。

难度：medium

解法：对元素进行计数，得到`(个数,值)`的统计。将统计放入一个<b>最大堆</b>，每次取出<b>个数最多</b>的元素，<b>拿走1个，设置cd=1</b>，cd过了才能重新放入堆中。实际上游戏里的<b>cd机制</b>就是这么实现的，用一个<b>冷却队列</b>，配合<b>计时机制</b>。不用<b>最大堆</b>的话，也可以用<b>哈希表+排序</b>实现，但方式更复杂，且难想。还是用<b>堆</b>吧。

<hr>

1055 Shortest Way to Form String

题意：给定字符串s和t，请从s中选出<b>最少的子序列</b>，使得这些<b>子序列相连</b>等于t。

难度：medium

解法：付费题。DP思路很容易想，不细说了。但这题是<b>贪心还是DP</b>？其实是<b>贪心</b>。比如`t[i:j]`是s的子序列，`t[i:j+1]`不是子序列。那我选`t[i:j]`就是按照<b>尽可能长</b>的原则。但如果我故意选`t[i:j-1]`，舍弃最后一个字符，我能得到<b>更优解</b>吗？答案是<b>不能</b>。对于下一段匹配，你<b>刚才舍弃的字符</b>，至多这次能用上，也可能用不上。用上了，你得到<b>相同的解</b>；用不上，你只能得到<b>更差的解</b>。因此，贪心思路是<b>最优的</b>。按照每次<b>尽可能多匹配</b>的原则，扫描t串即可。总代价`O(nt*ns)`，平均代价则<b>很接近`O(nt+ns)`</b>。

<hr>

1056 Confusing Number

题意：给定一个整数，如果旋转180度后，变为一个<b>不同但依然合法</b>的数，称为<b>“迷惑数”</b>。请判断给定数n是不是迷惑数。

难度：easy

解法：付费题。处理`16890`的情况即可，`25`不算，虽然在<b>七段数码管</b>里，25旋转也有效。

<hr>

1057 Campus Bikes

题意：二维平面上，有n个工人和m个自行车。我们按照`(工人-车的距离,工人编号,自行车编号)`的升序，给工人分配自行车。请返回长度n的数组，表示<b>第i个工人</b>分到的<b>自行车编号</b>。

难度：medium

解法：付费题。要注意，不是从0~n-1号工人依次分自行车，而是从<b>所有配对里</b>，找<b>距离最小</b>的。因此，理论上你需要从O(n*m)个组合里找。暴力解法，就是直接<b>枚举所有组合</b>，按给定的优先级进行<b>排序</b>。按这题的数据量，其实<b>这样就过了</b>。如果想<b>优化</b>，可以额外做一些<b>排序过滤</b>，提前筛选掉很多<b>无用的配对</b>。

<hr>

1058 Minimize Rounding Error to Meet Target

题意：给定一些浮点数prices，你可以对每个值取`floor`或者`ceil`。请问能否得到总和`target`？如果可以，请返回最小的<b>总舍入误差</b>。否则返回“-1”。

难度：medium

解法：对于floor和ceil，差值至多是1。因此，可以把所有元素都变为<b>“0或1”</b>这样处理，减掉一个<b>`floor(x)`的偏移量</b>。如果减去之后，target不在`[0,n]`范围内，则<b>无解</b>。难点在于求出<b>“总舍入误差”</b>，而且要求<b>最小</b>。因此，需要对<b>舍入部分做排序</b>。<b>靠近1</b>的取ceil，<b>靠近0</b>的取floor，这样总舍入误差就是最小的。这题还挺难，<b>思路不太好想</b>。

<hr>

1059 All Paths from Source Lead to Destination

题意：给定有向图和起点终点src、dst，请判断从src发出的路径，无论怎么走，最终<b>一定会停在dst</b>。

难度：medium

解法：付费题。意思就是<b>条条大路同罗马</b>。这个条件很严格，要求src和dst需要连通，且从src<b>可达的点</b>里，出度为0的只有dst一个。而且，<b>不能有环</b>。可以用<b>DFS或者拓扑排序</b>处理，建议DFS。执行DFS时，记录路径，如果路径里有<b>重复节点</b>，则表示有环。如果路径里的点已经在<b>其他路径</b>访问过了，也可以跳过。判断一下<b>出度为0的末端点</b>是否只有dst。

<hr>

1060 Missing Element in Sorted Array

题意：给定有序数组nums，从nums[0]开始，一直+1。请找出<b>第k个</b>缺失的值。比如`[4,7,9,10]`，则<b>第3个缺失值是8</b>，5、6、8。

难度：medium

解法：付费题。显然，O(n)的解法很直白，往下<b>数数</b>就行。那么如何<b>二分</b>呢？我们看看每个相邻元素`(nums[i],nums[i+1])`之间，<b>缺失了多少值</b>。得到一个缺失个数`miss_count`的统计，对这个做<b>前缀和</b>得到`miss_sm`。然后对这个`miss_sm`做二分搜索就行了，剩下不说了。实际写法更简单，直接用`a[mm]-a[ll]`就行了。

<hr>

1061 Lexicographically Smallest Equivalent String

题意：给定s1、s2等长字符串，其中`s1[i]-s2[i]`表示两个字符的等价关系，比如`a-b`表示ab等价。已知等价关系是对称、传递的，即`ab等价且bc等价->ac等价且ca等价`。给定s1、s2定义的等价关系，和一个字符串baseStr，请对baseStr做等价变换，得到<b>字典序最小</b>的结果。返回这个结果。

难度：medium

解法：题目是真的绕嘴，<b>完全不知所云</b>。其实看明白后，很容易想到<b>等价类、无向图连通分量</b>，因此用<b>并查集</b>。对于baseStr的<b>每个字符c</b>，都找出<b>和c等价的所有字符</b>中，<b>最小的一个</b>。所有字符都变为最小，总结果就是<b>字典序最小</b>。

<hr>

1062 Longest Repeating Substring

题意：给定字符串s，请找出其中最长的子串ss，使得ss在s中至少出现两次。位置可以<b>重叠</b>。

难度：medium

解法：付费题。直接<b>枚举i、j两个位置</b>进行匹配，看能匹配多长。总代价`O(n^2)`。

<hr>

1063 Number of Valid Subarrays

题意：给定数组nums，请求出符合条件的<b>子数组个数</b>，要求子数组的<b>0号元素是最小值</b>。

难度：hard

解法：付费题。我们考虑`nums[i]`，i位置往前<b>延伸多长</b>，`nums[i]`能保持最小值？那么直白的解法就是`O(n^2)`的枚举了。因此最优解必须是`O(n)`的。看例子，`[1,4,2,5,3]`，我用一个<b>递增的单调栈</b>。栈的变化情况是`[1]->[1,4]->[1,2]->[1,2,5]->[1,2,3]`。想想<b>4出栈的时候</b>，发生了什么？4遇到了2，因此<b>4不再是最小值</b>了，就出栈了，4对应的<b>边界</b>就找到了。比如<b>i元素的边界是j</b>，也就是说`i<j,nums[i]>nums[j]`（也可能`j==n`，出界了）。那么i元素总共对应了<b>`j-i`个子数组</b>。累加起来，总代价`O(n)`。

<hr>

1064 Fixed Point

题意：给定有序且无重复值的数组A，请找出第一个满足`A[i]=i`的位置i。如果不存在则返回-1。

难度：easy

解法：付费题。<b>二分搜索。</b>

<hr>

1065 Index Pairs of a String

题意：给定文本text和词表words，请找出所有`(i,j)`位置，使得`text[i:j+1]`是词表中的词。

难度：easy

解法：付费题。<b>暴力匹配</b>就行了。

<hr>

1066 Campus Bikes II

题意：1057的变体。这次分配自行车的目标，改为所有`工人-自行车`的<b>距离总和</b>最小。

难度：medium

解法：付费题。乍一想，应该很难。看数据范围<b>`<=10`</b>，说明确实很难。那就<b>暴力搜</b>？虽然是暴力搜，因为数据只有10，可以用<b>位压缩</b>提高效率，用`1<<nb-1`的掩码来表示<b>哪些自行车已经被分配</b>。除此之外，没什么特别技巧了。

<hr>

1071 Greatest Common Divisor of Strings

题意：给定字符串s和t，如果`s=t重复n次`，则称t是s的<b>“约数”</b>。现在给定s1、s2，请求出<b>“最大公约数”</b>，如果不存在则返回“”。

难度：easy

解法：题目难度既然是easy，那就可以<b>暴力匹配</b>了。对于每个串，找出最短的循环节t1、t2。因为是<b>最短循环节</b>，如果`t1!=t2`，则这个公约数<b>一定不存在</b>。如果相等，则考虑n1和n2的最大公约数。最终结果就是`t*gcd(n1,n2)`。对于<b>最短循环节</b>，高效的匹配算法是<b>KMP算法</b>。不想手写KMP的话，直接用`re.match`做暴力匹配就行了。

<hr>

1072 Flip Columns For Maximum Number of Equal Rows

题意：给定m x n的01矩阵，你可以任意选择某列，<b>反转整列的值</b>。请求出能得到的<b>整行值全0或全1</b>的最大行数。

难度：medium

解法：我们先假定某个第i1行变成全1了，这时<b>恰好某个i2行</b>也是全1。我在反转1列时，所有值都一起变，这代表i1行和i2行在任何时刻，都<b>长得一模一样</b>。因此，对于一个01串s，我用`1-s`表示取反结果。则当s变成全1，`1-s`也就成了全0。因此，我可以用<b>哈希表</b>，统计<b>每行的01字符串</b>的个数。比如`00101`有3个，`11010`有2个，那么我经过一些反转，就可以得到3个`11111`和2个`00000`，共5个。思路总结，就是`max(mm[s]+mm[inverse(s)])`。总代价<b>O(m*n)</b>。python是支持<b>大数运算</b>的，你甚至不需要字符串，直接<b>位操作</b>就行了。

<hr>

1073 Adding Two Negabinary Numbers

题意：给定两个-2进制的大数arr1、arr2，最高位在左边。请做<b>加法</b>。

难度：medium

解法：首先<b>反转一下</b>，最低位放左边。`1+1=2`，进位的话，`2*(-2)^k=-(-2)^(k+1)=(-2)^(k+2)+(-2)^(k+1)`，就按这个逻辑处理。当然还有一种<b>偷懒的办法</b>，就是转成10进制，再转回-2进制。对于python当然方便，因为<b>大数运算</b>是内部支持的。其他语言就不一定了。

<hr>

1074 Number of Submatrices That Sum to Target

题意：给定m x n矩阵和一个值target。请统计<b>子矩阵和</b>为target的个数。

难度：hard

解法：枚举子矩阵和，我们如果枚举<b>左上、右下</b>两个角，用<b>前缀和</b>的方式计算，总代价就是<b>O(n^4)</b>。难度hard，当然<b>不会这么简单</b>。因此，要优化。那么，我们枚举<b>行维度i1、i2</b>，这是O(n^2)，得到的就是一个<b>一维数组</b>。求一个数组里，<b>子数组和</b>为target的个数，这个<b>O(n)时间搞定</b>，会做吧？剩下不说了。所有这题关键，就是<b>问题转化的能力</b>。总代价<b>O(n^3)</b>。

<hr>

1078 Occurrences After Bigram

题意：给定一个句子和<b>a、b两个词</b>，如果句子中某词c按照<b>a、b、c</b>连续出现，返回所有这样的词c。

难度：easy

解法：水题。

<hr>

1079 Letter Tile Possibilities

题意：给定一些积木，积木上有字母`tiles[i]`。请求出用这些积木，能拼出的不同序列。可以<b>选部分或者全部，顺序任意</b>。

难度：medium

解法：显然，这个组合数<b>非常非常多</b>。数据稍微一大就<b>炸了</b>，因此给定的规模很小，直接<b>暴力搜</b>吧。很奇怪，我以前为什么写了个<b>这么麻烦的解法</b>。

<hr>

1080 Insufficient Nodes in Root to Leaf Paths

题意：给定二叉树，我们统计所有根到叶的路径。如果对于某节点p，所有<b>经过它的路径</b>，总和都小于limit，则称这个节点p<b>“不足”</b>。请<b>删除</b>所有不足的节点，返回修改后的二叉树。

难度：medium

解法：反过来，如果某条路径的`总和>=limit`，则路径上所有点都是<b>充足</b>的。那么我们可以递归一次，标记出所有的<b>充足点</b>。然后再递归一次，<b>从上到下</b>删除不足点。删除某点p，就等于<b>删除p的整个子树</b>。当然，这个思路也可以<b>一次递归完成</b>。

<hr>

1081 Smallest Subsequence of Distinct Characters

题意：给定字符串s，请找出一个<b>字典序最小</b>的子序列ss，使得ss包含了<b>s中的所有唯一值</b>，且<b>ss无重复字符</b>。

难度：medium

解法：三个要求：字典序最小、包含s的所有值、无重复值。对于26个字母，ss的最大长度也就26。那么我们不用想得很复杂。对应s的每个字符，我们总是比较当前字符如果<b>替换进去</b>，能否得到<b>字典序更小</b>的结果。能，我就放进去。比如`cbacdcbc`，依次判断的结果是`c->cb->cba->bac->bacd->acdb`，其中有两处没有替换，因为替换之后<b>字典序会变大</b>。匹配的总代价是<b>O(n*26)</b>，也等于O(n)。看了下我以前的代码，和上面这个思路<b>不一样</b>。

<hr>

1085 Sum of Digits in the Minimum Number

题意：给定数组nums，判断<b>最小元素</b>的<b>数位之和</b>是否为<b>奇数</b>。

难度：easy

解法：付费题。一句话给了<b>3个要素</b>，真简洁。

<hr>

1086 High Five

题意：给定一些`(学生ID,分数)`的记录，请返回每个学生<b>前5高</b>的分数的<b>均值</b>，按<b>ID升序</b>排列。

难度：easy

解法：付费题。题目很清晰，按要求实现即可。

<hr>

1087 Brace Expansion

题意：给定一种<b>语法</b>，对序列进行展开。用`{a,b}`表示一个含有a、b的集合，用`{a,b}{c,d}`表示ab集和cd集的<b>笛卡尔积</b>，结果为`["ac","ad","bc","bd"]`。给定一个序列，请按语法规则进行<b>展开</b>。给定序列不包含<b>嵌套括号</b>，结果按字典序升序排列。

难度：medium

解法：付费题。既然不包含<b>嵌套括号</b>，那问题就简单点。字符串处理+求笛卡尔积，形式上可以写一个DFS函数，用<b>搜索的思路</b>去做。

<hr>

1089 Duplicate Zeros

题意：给定数组nums，请将其中的0值复制一遍。比如`00`，则变成`0000`。非零元素需要按顺序后移，如果<b>位置不够，则丢弃</b>。请<b>就地修改</b>数组，不返回任何值。

难度：easy

解法：因为要移动非零元素，我们可以先<b>从前往后</b>，统计0的个数。这样就可以确定<b>偏移量</b>了。再<b>从后往前</b>，按偏移量，<b>`>n-1`位置</b>的元素丢掉。<b>在界内</b>的元素，依次填进去。

<hr>

1090 Largest Values From Labels

题意：有n件物品，各有类型`lables[i]`和价值`values[i]`。你需要从中选出<b>至多</b>`numWanted`件，且<b>同类型</b>不能超过`useLimit`件。请求出得到的<b>最大价值总和</b>。

难度：medium

解法：<b>看着很难，其实不难。</b>首先，我肯定应该选够`numWanted件`，<b>没理由少拿</b>。然后，<b>贪心还是DP？</b>应该是<b>贪心的</b>。我直接按`values`降序排列，<b>尽量拿大的</b>。同时，保证遵守`useLimit`的限制即可。

<hr>

1091 Shortest Path in Binary Matrix

题意：给定n x n的01矩阵。请找出一条<b>全0的8邻接</b>路径，从`(0,0)`出发到达`(n-1,n-1)`。

难度：medium

解法：最短路径，这好像直接<b>BFS</b>就行了。按照<b>0格子、8邻接</b>的要求，搜吧。如果希望快一点，还可以<b>双向BFS</b>。这题<b>单向BFS足够了</b>。

<hr>

1093 Statistics from a Large Sample

题意：给定一个`[0,255]`范围的抽样。值范围不大，但是<b>抽样个数非常多</b>。现在给定统计结果`count[i]`表示<b>i值的个数</b>。请求出min、max、mean、median、mode。<b>mode是众数</b>。

难度：medium

解法：这题出得很好，<b>统计学是个好东西</b>。min、max、mean、mode都不说了，很简单。中位数median，可以用`count[i]`计算<b>累加和</b>，看看<b>中间</b>落在<b>哪个值i</b>上。注意<b>特殊情况</b>，如果中间值恰好在<b>`i`、`i+1`的边界</b>，那就是`i+0.5`。

<hr>

1094 Car Pooling

题意：在数轴上，所有位置的<b>初始值为0</b>。给定一些区间`[x,y,val]`和一个capacity值，表示<b>给每个[x,y]区间+val</b>。如果给定的区间可能存在重叠，请判断是否存在某个区间的值<b>超过了capacity</b>。

难度：medium

解法：题目说的拼车问题，转成<b>数学模型</b>，就是<>如上所述。区间+val，这个可以转化成`[0,x-1,-val]`和`[0,y,+val]`两个操作。因此，你可以用<b>后缀和</b>处理，也可以用<b>树状数组</b>处理。x、y的<b>数据范围不超过1000</b>，因此建议用后缀和的方式，<b>简单易实现</b>。

<hr>

1096 Brace Expansion II

题意：1087的变体。给定一种<b>语法</b>，对序列进行展开。用`{a,b}`表示一个含有a、b的集合，用`{a,b}{c,d}`表示ab集和cd集的<b>笛卡尔积</b>，结果为`["ac","ad","bc","bd"]`。如果集合只有一个元素，<b>可以省略“{}”</b>现在给定一个这样的序列，请按如上规则，进行<b>递归展开</b>，返回最终结果。

难度：hard

解法：题目本身倒是定义明确，也没什么特别动脑的地方。因此hard主要体现<b>麻烦</b>。<b>字符串处理+递归解析</b>即可，很费劲的一道<b>体力题</b>。注意对结果进行<b>去重和排序</b>。

<hr>

1099 Two Sum Less Than K

题意：给定数组A和值k，请求出`i<j,A[i]+A[j]`能得到的最大值s，且`s<k`。返回s，如果不存在，则返回-1。

难度：easy

解法：付费题。排序之后，双指针从`i=0,j=n-1`向中间靠拢。排序代价为主，因此总代价`O(nlogn)`。

<hr>

1100 Find K-Length Substrings With No Repeated Characters

题意：给定字符串s，请统计长度为k，且没有重复字符的子串个数。

难度：medium

解法：付费题。这个滑动窗口的<b>大小是固定的</b>，因此非常简单。<b>滑动+统计</b>，看看<b>唯一值个数是否为k</b>就行了。

## 1101 - 1200

1101 The Earliest Moment When Everyone Become Friends

题意：n个人，编号`0~n-1`，给定一些日志logs，格式为`[t,x,y]`，表示x和y在t时刻交朋友。如果x、y通过任意个人<b>间接认识</b>，也算认识。请问<b>最早在什么时刻</b>，所有人都认识了？

难度：medium

解法：付费题。很明显，<b>并查集</b>。

<hr>

1102 Path With Maximum Minimum Value

题意：给定m x n矩阵A，请求出一条从`(0,0)`到`(m-1,n-1)`的路径，可以<b>上下左右</b>走。要求路径经过格子的<b>最小值最大</b>。

难度：medium

解法：付费题。能上下左右，你可能会考虑<b>“回头路”</b>的问题。其实无所谓，你知道这题肯定要搜，问题是<b>怎么搜</b>？答案是BFS，而且用<b>最小堆</b>。最小堆这个思路还有点难想。如果用<b>纯粹的BFS</b>，因为涉及大量<b>无效搜索</b>，效率上不可接受。

<hr>

1103 Distribute Candies to People

题意：你有c个糖果分给n个人。按照`1,2,3...,n,n+1,n+2,...`这样，从1~n人分配，每满n人，回到第1人继续发，直到发完。请返回每个人拿到的糖果数。

难度：easy

解法：水题。用算数技巧算一下。

<hr>

1104 Path In Zigzag Labelled Binary Tree

题意：有一棵无限层的<b>满二叉树</b>。从根节点开始，依次按照<b>左右左右交替顺序</b>遍历每层，依次编号为`1,2,3,...`。现在给定对应<b>序号label</b>。请返回从根到该节点的<b>路径序号</b>。

难度：medium

解法：虽然每层顺序反了一下，但个数是固定的，因为满二叉树的每一层个数都是`2^k`。那么<b>先求出label对应的节点</b>，再根据节点确定每走一步到哪儿，对应位置的序号是什么就行了。<b>用嘴说不清楚</b>，在草稿纸上<b>画一下，列出公式</b>并不难。

<hr>

1105 Filling Bookcase Shelves

题意：你有n本书，你可以<b>依次</b>，按照从左到右、从下到上的顺序，摆成一层层的。不能调整<b>书的顺序</b>，依次。给定每本书的<b>厚度、高度`(th_i,h_i)`</b>，和每层的总宽度`shelfWidth`，要求每层书的厚度不能超过总宽度，超过了需要新加一层。每层的高度则按照`max(h)`处理。请求出最终得到的<b>总高度的最小值</b>。

难度：medium

解法：题目描述<b>相当费解</b>，没有配图的话，完全无法理解<b>到底在问什么</b>。转化为数学模型，其实相当于把`[th,h]`数组<b>划分为几个子数组</b>，要求`sum(th)<=shelfWidth`，目标是`min(sum(max(h)))`。<b>啥玩儿，确实够复杂。</b>我能想出一个`O(n^2)`的<b>DP思路</b>。用`dp[i]`表示`[0:i+1]`段的最优解。则枚举[j+1:i+1]这段作为<b>一层</b>，首先判断能否装进一层`sum(th[j+1:i+1])<=shelfWidth`，再求`dp[j]+max(h[j+1:i+1])`。因此`dp[i]=min(dp[j]+max(h[j+1:i+1]))`。这其中的某些计算，比如`sum、max`都可以通过<b>预计算</b>来加速，这样总代价能控制在O(n^2)。

<hr>

1106 Parsing A Boolean Expression

题意：给定布尔表达式，请进行解析求值。要求支持`tf`作为基本值，运算包括`! & | ()`这几种。

难度：hard

解法：难度是hard，其实没有算法上的难度，就是<b>字符串解析+运算处理</b>了。并没有特别<b>复杂或者坑人</b>的情况。对于单目、二目、三目甚至n目运算符，应该设计出一套统一的<b>文法机制</b>去处理，以免代码写得case by case过于冗长。括号是<b>改变优先级</b>的，肯定要特殊处理。

<hr>

1108 Defanging an IP Address

题意：对于IP地址，把“.”替换为“[.]”。

难度：easy

解法：水题。<b>defang</b>的意思是<b>拔牙</b>，fang是尖牙。IP defang是指的对IP地址做<b>无效化处理</b>。

<hr>

1109 Corporate Flight Bookings

题意：给定区间`[1,n]`，初始值都是0。每次对区间`[x,y]+val`。经过若干次操作，请求出每个位置的值。

难度：medium

解法：题目本身的一些“航班”、“座位”之类的就不说了。<b>区间修改，单查</b>。这是典型的<b>树状数组</b>应用，但因为是<b>批处理问题</b>，不需要树状数组，直接做<b>后缀累加</b>即可。总代价O(n)。

<hr>

1110 Delete Nodes And Return Forest

题意：给定二叉树，请删除所有值为val的节点。因为操作可能生成多棵树，请返回得到的<b>树林</b>。树的所有节点<b>没有重复值</b>。

难度：medium

解法：题目本身并不难，<b>递归执行</b>。记录好<b>父节点</b>，以便更新指针。比如当前节点r需要删除，那就把父节点的对应child位置<b>置空</b>，同时继续往下搜。返回的<b>所有树</b>，要汇总到一起。其实就算有<b>重复值</b>，思路也是一样。

<hr>

1111 Maximum Nesting Depth of Two Valid Parentheses Strings

题意：括号序列，规则就不说了。我们定义括号序列的深度为"()"嵌套的<b>最大层数</b>。如果序列`A+B`，则按`max(d(A),d(B))`处理。空串的深度为0，`d((A))=d(A)+1`。现在给定一个序列S，请将其划分为两个子序列A、B，使得max(d(A),d(B))最小。注意，是<b>子序列</b>，不是子串。

难度：medium

解法：是<b>子序列</b>，不是子串。那么问题就是，对于每个s[i]，应该分配给A还是B？看数据范围，`O(n^2)`的DP思路应该不行，而且我也想不出来。那么<b>贪心</b>行不行？给定已有的A、B序列，分别用栈模拟，称为sa、sb。首先，我可以处理整个s，看下整个序列的<b>最大深度</b>是多少，命名为`max_cnt`。其实，你只要保证`cnt`不超过`max_cnt/2`就行了，<b>想想为什么</b>。就这个，<b>贪心</b>。不超过，给A；超过了，给B。

<hr>

1118 Number of Days in a Month

题意：给定年Y月M，请求出这个月有几天。

难度：easy

解法：付费题。判断<b>闰年</b>即可。

<hr>

1119 Remove Vowels from a String

题意：给定字符串，请删除其中的<b>aeiou</b>。

难度：easy

解法：付费题。水题。

<hr>

1120 Maximum Average Subtree

题意：给定二叉树，请求出所有子树中，<b>平均值的最大值</b>。

难度：medium

解法：付费题。思路很明确，递归<b>求和+计数</b>，用`sum/count`就是平均值。用<b>后序遍历</b>。

<hr>

1122 Relative Sort Array

题意：给定数组a1、a2，a2没有重复值。对a1中的值x，如果x在a2中，则按a2元素顺序排列；如果不在a2中，则升序排列并放到a1末尾。

难度：easy

解法：付费题。水题，要求繁琐且无聊。用<b>哈希表+排序</b>解决。

<hr>

1123 Lowest Common Ancestor of Deepest Leaves

题意：给定二叉树，请找出它的所有<b>最深叶节点</b>的<b>最近公共祖先</b>。

难度：medium

解法：不用去考虑<b>LCA问题</b>的专门解法。这个用<b>后序遍历，递归处理</b>就行。比如<b>当前节点r</b>，我考虑r对应子树的<b>叶节点最大深度d(r)</b>。那么，如果`d(r.left)==d(r.right)==max_d`，则答案可能是r，但<b>还需要往上找</b>，因为别处也可能有同样深度的子树。这个`max_d`可以单独遍历一次得出。随着往上找，同时更新答案。因为是后序遍历，<b>最终答案</b>肯定是某个<b>深度最小的点r</b>，满足上面那个式子。因为它必须<b>足够靠上</b>，才能覆盖到所有的<b>最深叶节点</b>。

<hr>

1128 Number of Equivalent Domino Pairs

题意：一个积木，尺寸为a x b。已知<b>a x b和b x a等价</b>，可以转一下。给定一些积木，请求出<b>等价的对数</b>。

难度：easy

解法：水题。

<hr>

1129 Shortest Path with Alternating Colors

题意：给定有向图，可能存在自环、多重边。图里存在红边、蓝边两种颜色，从0出发，请求出到所有点的<b>最短路径长度</b>，但是要求路径必须<b>红蓝交替或者蓝红交替</b>。如果不可达，则返回-1。

难度：medium

解法：虽然有自环、多重边，还有红蓝颜色要求，毕竟所有边都是长度1，这对于<b>常规的BFS</b>来说没什么区别。注意搜索时按照<b>颜色交替</b>即可。

<hr>

1130 Minimum Cost Tree From Leaf Values

题意：一棵二叉树，它的所有非叶结点，都是`左子树最大叶*右子树最大叶`，<b>乘积</b>。如果已知中序遍历里，所有叶子值是数组arr，请求出<b>非叶节点</b>的<b>最小和</b>。

难度：medium

解法：题目描述太复杂了，看得头晕。其实，所谓的<b>“二叉树”</b>完全是<b>烟雾弹，迷惑你的</b>。直接按照`dp[left]`、`dp[right]`去针对arr数组进行<b>子问题划分</b>，而且很容易看出这是个<b>DP问题</b>。这样，你根本不用考虑二叉树的事情，会发现也不算很难。细节就不说了。针对`dp[i][j]`，枚举中间的k，总代价`O(n^3)`。

<hr>

1131 Maximum of Absolute Value Expression

题意：给定同长度的数组a1、a2，任选(i,j)位置，请求出`|a1[i]-a2[j]|+|a2[i]-a1[j]|+|i-j|`的最大值。

难度：medium

解法：显然题目希望你用低于`O(n^2)`的代价解决。没想出好思路，看了下当年代码，<b>当年也没想出来</b>。网友的思路给人的感觉就是<b>实在巧妙</b>。为了处理<b>绝对值</b>问题，可以通过枚举两个<b>绝对值</b>展开之后的<b>正负号</b>，这样共有`2*2=4`种组合。还要对这个式子做一下拆分，把i项归到一起，j项归到一起。总之，这个<b>神思路</b>我没法独立想出。当然，如果解决<b>某类问题</b>，必须用<b>某种思路</b>，那唯一办法就是<b>学会+记住</b>。

<hr>

1133 Largest Unique Number

题意：给定数组arr，求出其中只出现一次的最大值。

难度：easy

解法：付费题。水题。

<hr>

1134 Armstrong Number

题意：如果一个数n的所有<b>数位的立方</b>，加起来等于n，则称为<b>“Armstrong数”</b>。请判断给定n是否符合要求。

难度：easy

解法：付费题。水题。

<hr>

1135 Connecting Cities With Minimum Cost

题意：给定一些<b>双向边`[x,y,c]`</b>，表示连通x、y的代价为c。请求出连通所有边的<b>最小总代价</b>。

难度：medium

解法：付费题。题目翻译过来，就是<b>最小生成树</b>。因此，用<b>并查集，Kruskal算法</b>。

<hr>

1137 N-th Tribonacci Number

题意：有个序列，类似Fibonacci数列，但形式是`Tn=Tn-1+Tn-2+Tn-3`。给定初始值，请求出Tn。

难度：easy

解法：水题。

<hr>

1138 Alphabet Board Path

题意：26个字母，按照<b>从左到右、从上到下</b>，共5 x 5，加上一个z。现在给定一个字符串target。你可以执行“UDLR”移动，或者“!”选取当前字符。请给出一个执行序列，使得得到的字符串等于target，要求序列长度最短。

难度：medium

解法：这是个<b>模拟题</b>。从起点a开始，字符的<b>位置是确定的</b>，因此也不存在什么<b>“最短路”</b>，直接按顺序走就行了。一个个走，记录下<b>执行的序列</b>即可。唯一要注意的，是z。z的位置必须先经过u。

<hr>

1139 Largest 1-Bordered Square

题意：给定01矩阵，请求出一个最大的<b>正方形</b>，使得正方形<b>边缘都是1</b>。返回最大边长，如果不存在则返回0。

难度：medium

解法：对于每个点`grid[i][j]`，我都考虑上下左右的连续1有多少个。这个计算代价，在四个方向都是`O(n^2)`。然后我枚举左上、右下两个角，左上`O(n^2)`，右下`O(n)`，因为是<b>正方形</b>。左上在`(x,y)`，右下在`(x+d,y+d)`。然后我判断<b>左上向右向下，右下向左向上</b>的连续1的个数<b>够不够d个</b>就行了。对每一次枚举，判断代价都是`O(1)`。因此，总代价是`O(n^3)`。

<hr>

1140 Stone Game II

题意：877的变体。有n堆石头，每堆个数为`piles[i]`。两人轮流，每次可以拿`1<=X<=2M`堆石头，开始`M=1`。拿完之后，`M=max(M,X)`。拿完为止，问<b>先手是否必胜</b>。

难度：medium

解法：<b>一天到晚拿石头</b>，也是服了。肯定<b>DP</b>了，那么状态怎么定？比如我用`dp[i][j]`表示`[0:i+1]`堆，且最后一步拿了j堆的最优解。这样行吗？<b>不行。</b>因为你知道最后一步，但无法确定<b>第一步是谁拿的</b>，Alice还是Bob？即使求出结果，也<b>不知道属于谁</b>。因此需要反过来，用`dp[i][j]`表示`[i:n]`堆，且最后一步拿了j堆。这样的话，`dp[0][0]`就表示<b>初始状态</b>搜到最后的结果。这个逻辑<b>用循环有点难写</b>，建议<b>记忆化搜索</b>。当年好像直接<b>没做出来</b>，这次思路很快想到了。

<hr>

1143 Longest Common Subsequence

题意：最长公共子序列，<b>LCS问题</b>。

难度：medium

解法：没错，就是教科书的LCS问题。<b>DP</b>的最经典例子，总代价`O(n^2)`。

<hr>

1144 Decrease Elements To Make Array Zigzag

题意：给定数组nums，每次允许任选一个元素<b>-1</b>。请问至少多少次操作，能使数组变为<b>“大小大小”</b>或<b>“小大小大”</b>的交替形式。

难度：medium

解法：既然只有大小大小或者小大小大两种方式，那就<b>两种都试试</b>。比如abc三个元素，你可以把b变成`min(a,c)-1`，或者`max(a,c)+1`，这个操作是确定的，因此可以`O(1)`代价求出。这样，只需要两次`O(n)`代价的遍历，就能得到答案。你可能会想，对于abc，我能不能通过修改<b>两个元素</b>，而不是<b>只修改b</b>，得到更小的代价？答案是不能，也没必要，可以<b>想想为什么</b>。

<hr>

1145 Binary Tree Coloring Game

题意：给定n节点的二叉树，所有节点的值恰好是`1~n`，不重复。两人轮流给每个节点选值，要求各不相同。按照<b>红蓝红蓝</b>交替。除了第一次以外，之后选择的点，都必须和已涂色的点<b>相邻</b>。红找红，蓝找蓝。如果一方无法涂色，则<b>跳过</b>，如果双方无法涂色，则<b>结束</b>。请判断<b>后手是否必胜</b>。

难度：medium

解法：终于轮到<b>后手</b>了。既然要求选的点必须和之前相邻，这相当于是<b>洪泛</b>了，flooding。那比如先手<b>选了x</b>，x的子树有nx节点，则剩余部分有`n-nx`。则y可以选在x的父节点，如此的话，<b>剩余的`n-nx`都被y堵住</b>，因此也属于y了。所以，x不会选一个`nx<n-nx`的位置。那么x一定选根节点，y则选<b>左右子树</b>里<b>较大的一个</b>。那么，<b>如果左右子树一样大，y必输</b>。n是奇数，因此不可能平手。除了y必输的一种情况，其他的y必胜。因此，这题是个<b>坑爹智力题</b>。

<hr>

1146 Snapshot Array

题意：设计一个<b>数组</b>结构，支持类似快照功能。n元素，支持元素赋值，支持存储快照返回ID，支持获取特定`arr[i]`的对应`snap_id`的值。

难度：medium

解法：如果你要保证查询`O(1)`，那写入就很难做到`O(1)`。因为快照理论上应该<b>对所有元素都保存一份</b>，但这样<b>太浪费空间</b>。我们换种思维，只记录当前snap<b>修改了什么</b>。比如`snap_id=0`时，无事发生，那我什么都不记（当然，初始化时有0值，这个也算记录）。比如`snap_id=t`时，我把`arr[i]=x`，那我可以用`arr[i].append((t,x))`来表示这个修改。当我要查询快照记录时，则可以对`snap_id`进行二分搜索。这样能用`O(logn)`代价定位到<b>`<=snap_id`的最近记录</b>。修改代价为`O(1)`，查询代价为`O(logn)`，总体效率很好。

<hr>

1150 Check If a Number Is Majority Element in a Sorted Array

题意：给定有序数组nums，请判断某元素target是否为<b>众数</b>。

难度：easy

解法：付费题。可以二分搜索，用<b>bisect_left+bisect_right</b>快速找到边界，判断个数是否`>n/2`。

<hr>

1151 Minimum Swaps to Group All 1's Together

题意：给定01数组data，请求出最小的交换次数，使得所有1能<b>聚拢到一起</b>。

难度：medium

解法：付费题。很简单，统计1的个数，比如<b>总共k个</b>。那我就判断所有的k窗口里，<b>0个数的最小值</b>。这就是答案。

<hr>

1152 Analyze User Website Visit Pattern

题意：给定一些网站访问记录，按`(u,w,t)`格式，表示用户u在t时刻访问了w站。给定用户访问最多的<b>前3网站</b>，结果<b>升序</b>。如果存在多个则按<b>字典序升序</b>。

难度：medium

解法：付费题。题目描述很清晰，就是<b>排序</b>。tuple排序，结果也排序。

<hr>

1154 Day of the Year

题意：给定`YYYY-MM-DD`格式的日期，求出这是当年的第几天。

难度：easy

解法：也没什么技巧，按月份累加。

<hr>

1155 Number of Dice Rolls With Target Sum

题意：你有n个色子，每个是k面，也就是`1~k`。给定目标总和target，请求出摇n个色子，有<b>多少种结果</b>，加起来等于target。结果模`1e9+7`返回。

难度：medium

解法：<b>DP解法</b>，显然可以用`dp[i][j]`表示<b>i个色子和为j</b>的个数，剩下不说了。

<hr>

1156 Swap For Longest Repeated Character Substring

题意：给定字符串s，你可以选两个字符交换。请返回能得到的最长的<b>单值子串</b>长度。

难度：medium

解法：<b>滑动窗口</b>可以做，但又好像不是很方便。也可以统计<b>每个连续段</b>的字符个数，如果存在中间有个<b>单字符</b>的情况，尝试交换。总之，<b>题目不难</b>，但不论用什么办法都<b>有点点麻烦</b>。

<hr>

1160 Find Words That Can Be Formed by Characters

题意：给定字符chars和词表words。如果words中的词可以通过chars字符拼出（不能重复使用字符），则称为<b>好词</b>。请统计所有好词的长度之和。

难度：easy

解法：水题。哈希统计即可。

<hr>

1161 Maximum Level Sum of a Binary Tree

题意：给定二叉树，定义根节点<b>深度为1</b>，依次往下+1。对每层的节点求和，请返回单层总和最大的<b>对应层数x</b>。

难度：medium

解法：遍历求和即可，注意返回的是<b>层数</b>，不是总和。

<hr>

1162 As Far from Land as Possible

题意：给定n x n地形，0陆1水。请找出一个水格子，使其到达<b>最近的陆地最远</b>。返回对应距离，如果不存在则返回-1。

难度：medium

解法：不要从水格子去搜陆地，以<b>所有陆地格子</b>作为种子，<b>执行BFS</b>，去找水。

<hr>

1165 Single-Row Keyboard

题意：给定一个单排键盘，26个字母都在一排。从i移动到j，代价是`|i-j|`。开始你在0位置，请问给定单词word，移动手指的<b>代价总和</b>是多少？

难度：easy

解法：付费题。水题。

<hr>

1166 Design File System

题意：请设计一个建议的文件系统，处理<b>目录层次</b>。支持创建目录，并赋值；支持查询目录返回值，不存在则返回-1。创建目录需要保证<b>父目录已存在</b>，否则返回false。

难度：medium

解法：付费题。字符串处理，主要就是注意判断目录层次，检查父目录是否存在。后面还会有<b>读写文件</b>的设计题，比这个复杂。本身没有算法难度，用哈希表记录即可。

<hr>

1167 Minimum Cost to Connect Sticks

题意：你有一些棍子，长度为`sticks[i]`。连接长度x、y的棍子，代价为`x+y`。请问连到只剩一根棍子，<b>最小总代价</b>是多少？

难度：medium

解法：付费题。这显然类似<b>Huffman编码</b>，用最小堆处理。每次都选出最短的两根棍子，<b>贪心策略</b>。

<hr>

1170 Compare Strings by Frequency of the Smallest Character

题意：定义`f(s)`为字符串s中<b>最小字符</b>的频率。给定词表words和一些queries。针对每个查询，求出`f(q)<f(words[i])`的`words[i]`个数。

难度：medium

解法：<b>词表是固定的</b>，那么这个`f(w)`的统计不也是固定的吗？统计一次，<b>排序</b>。然后用`f(q)`进行二分查找，求个数就行了。总代价`O(nw*log(nw)+nq*log(nw))`。

<hr>

1171 Remove Zero Sum Consecutive Nodes from Linked List

题意：给定链表，请不断删除<b>累加为0的子链表</b>。返回最终结果。

难度：medium

解法：首先，你如果把<b>链表转成数组</b>，那就没什么难度了。但<b>原则上不允许</b>。实际上，可以针对<b>前缀和</b>做哈希统计。比如前缀和为x，存在两个点`p1、p2`，则代表<b>从`p1.next`到`p2`这段的和为0</b>，应该删掉。那么我记录了`p1`，就正好可以`p1.next=p2.next`了。注意<b>特殊case</b>，比如表头也删了。看了下我当年的代码，<b>思路正确</b>，但<b>写得挺难看的</b>。

<hr>

1175 Prime Arrangements

题意：给定`1~n`的排列，请求出<b>素数元素</b>恰好在<b>素数位置</b>的排列个数。下标按1开始，结果模`1e9+7`返回。

难度：easy

解法：数据范围不大，其实可以作为纯数学题处理。比如有p个素数，n-p个非素数，则<b>两者完全不相干</b>。结果不就是`p!(n-p)!`？n的范围很小，连<b>筛法</b>都不需要。

<hr>

1176 Diet Plan Performance

题意：一个人减肥，每天消耗卡路里是`calories[i]`。判断所有<b>k窗口的总和</b>，如果`<lower`，-1分；如果`>upper`，+1分。如果初始0分，请返回<b>最后总分</b>。

难度：easy

解法：付费题。水题。

<hr>

1177 Can Make Palindrome from Substring

题意：给定字符串s，和一些查询`q=[i,j,k]`。你可以针对s[i:j+1]子串做<b>任意排序</b>，替换其中<b>至多k个字符</b>。请判断能否得到一个回文串？针对每个查询，返回`true or false`。

难度：medium

解法：对于一个字符串，我们做哈希统计。只关心计数<b>有多少个奇数</b>，因为偶数就可以配对。比如我有cc个奇数，那么`max(cc-1,0)`个都需要<b>去掉</b>，才能得到回文串。每替换一个字符，我可以去掉两个奇数。因此，我需要替换`(max(cc-1,0)+1)/2`个字符。把这个<b>和k比较</b>即可。但这样还不行，因为代价是O(n^2)的，<b>会超时</b>。可以用<b>前缀和+位压缩</b>的方式，来高效统计<b>奇数的个数</b>。你看，是不是<b>瞬间高大上</b>了？其实不是前缀和，是<b>前缀异或</b>。总代价`O(n+qlog(int))`。

<hr>

1180 Count Substrings with Only One Distinct Letter

题意：给定字符串s，请求出单值子串的个数。

难度：easy

解法：付费题。水题。<b>数个数</b>，然后`n*(n+1)/2`。

<hr>

1181 Before and After Puzzle

题意：给定一些句子，按首尾词相连的方式，构造连接句子。语文里这叫<b>“顶真修辞”</b>。结果按<b>字典序</b>排序。

难度：medium

解法：付费题。亏我还记得顶真，<b>“从前有座山，山里有座庙”</b>之类的。本身思路很明确，对每个句子，记录它的首、尾词，作为<b>哈希key</b>。然后对<b>尾词</b>找匹配的<b>首词</b>，这样就可以<b>连句</b>了。

<hr>

1182 Shortest Distance to Target Color

题意：给定数组colors，其中有123三种值。给定一些查询`q=[i,c]`，请求出<b>距离i位置最近的c值</b>，给出<b>距离</b>，如果没有，则返回-1。

难度：medium

解法：付费题。对123都记录它们的位置，并保持有序，存放在`pos`数组中。那么查询`[i,c]`时，我针对`pos[c]`二分查找<b>i的位置</b>，用`bisect_left`找到<b>左右相邻的最近位置</b>即可。

<hr>

1184 Distance Between Bus Stops

题意：给定n个站点，形成<b>环路</b>。从`i`到`i+1`站的距离为`distance[i]`。如果可以两方向走，给定x、y站，请求出两者的最短距离。

难度：easy

解法：水题。

<hr>

1185 Day of the Week

题意：给定年月日，请求出<b>星期几</b>。

难度：easy

解法：我记得好像有个<b>神一般的一行公式</b>可以求这个。自己手写的话，好像不容易。特地看了下python的<b>库函数</b>实现，<b>这何止是复杂，摆烂吧。</b>以这个`(1 + 5((A−1) % 4) + 4((A−1) % 100) + 6((A−1) % 400)) % 7`<b>高斯公式</b>为起点，从1月1日开始数吧。

<hr>

1186 Maximum Subarray Sum with One Deletion

题意：给定数组nums，你可以选一个子数组，并删除其中<b>至多一个元素</b>，请求出能得到的<b>最大子数组和</b>。

难度：medium

解法：有<b>两种思路</b>。第一种，我选取一个子数组，想想从其中删除哪一个。肯定应该删最小的一个，因此我总需要获得当前子数组的最小值。这个思路应该可以，但我<b>没完全想清楚</b>。第二种，我选<b>一个，或者两个</b>子数组。如果选了两个，则中间<b>只能间隔一个元素</b>。我需要处理前缀max子数组、后缀max子数组，然后加起来。这个方法可以，思路也不难。总代价`O(n)`，额外空间也是`O(n)`。

<hr>

1189 Maximum Number of Balloons

题意：给定字符串，你可以选其中字符组成单词balloon。请问最多能组成多少个？

难度：easy

解法：水题，<b>计数</b>即可。

<hr>

1190 Reverse Substrings Between Each Pair of Parentheses

题意：给定一个包含<b>“()”和字母</b>的串，已知括号匹配。对于每个“(A)”，请将A的内容反转。括号可能存在多个<b>并列、嵌套</b>的情况。

难度：medium

解法：不用递归，用<b>栈</b>直接处理就行了。细节就不说了，很容易想。

<hr>

1191 K-Concatenation Maximum Sum

题意：给定数组arr和整数k，<b>将arr重复k次</b>，得到ak。请求出ak的最大子数组和，结果模`1e9+7`返回。

难度：medium

解法：首先，<b>如果arr的总和`>0`</b>，那我对于中间段，就应该全部算进去。对于结尾，则只取前缀max和后缀max。如果arr的总和`<=0`，则只能从`arr+arr`中找最大子数组，不能包含<b>一个完整的arr段</b>。总体上，这题挺麻烦的。每种case都不难，但<b>全考虑到</b>就很费劲。

<hr>

1196 How Many Apples Can You Put into the Basket

题意：给定数组arr，请从中选出总和不超过5000的元素，请问最多选几个？

难度：easy

解法：付费题。水题，<b>排序</b>即可。

<hr>

1197 Minimum Knight Moves

题意：给定一个无限大的棋盘，<b>马走日</b>。请问，从`(0,0)`出发，至少多少步可以到达`(x,y)`？

难度：medium

解法：付费题。<b>BFS</b>解决。对于无限大的棋盘，我们用<b>双向BFS</b>，效率能明显提高。

<hr>

1198 Find Smallest Common Element in All Rows

题意：给定m x n矩阵，已知每行都是有序的。请找出一个每行都存在的<b>最小公共值</b>。如果不存在，则返回-1。

难度：medium

解法：付费题。可以以<b>第0行</b>作为<b>基准</b>，对于`a[0][j]`，我都在其他所有行做二分搜索。这样，总的判断代价是O(mnlogn)。还可以用其他类似策略，总代价相同。大体思路，都是固定某1行，<b>搜索其他m-1行</b>。

<hr>

1200 Minimum Absolute Difference

题意：给定数组arr，请返回所有`i<j`，使得`|arr[i]-arr[j]|`最小。

难度：easy

解法：对`(arr[i],i)`排序，从<b>相邻元素</b>里找<b>最小差值</b>。

## 1201 - 1300

1201 Ugly Number III

题意：263的变体。这次abc三个因数<b>不一定是质因数</b>，可以是任意正整数。

难度：medium

解法：思路上<b>完全相同</b>。采用3指针，<b>每次取最小，前进一步</b>的办法。这个办法并不关心abc是否为质数，只关心哪个最小。

<hr>

1202 Smallest String With Swaps

题意：给定字符串s，给定<b>一些位置`[i,j]`</b>，你可以针对这些位置，做<b>任意次交换</b>。请求出能得到的<b>字典序最小</b>的字符串。

难度：medium

解法：这是个图论题，而且是<b>无向图连通分量</b>。为什么？比如我可以换`[0,2]`和`[2,5]`，则我其实可以把`[0,2,5]`这三个位置调整成<b>任意顺序</b>。既然如此，我把每个<b>这样的“小组”</b>都按升序排列，就是<b>字典序最小</b>的结果。求这些小组，可以用<b>并查集</b>。总代价`O(E+V)`，其中E是数对个数，V是字符串长度。

<hr>

1203 Sort Items by Groups Respecting Dependencies

题意：有一个表格，每一项记录都有一个<b>归属的组</b>。没有组的，组号按-1处理。现在给定一些<b>before关系</b>，比如`x before y`，表示x必须出现在y之前。请按照`(组,before)`维度排序，要求<b>同组记录</b>聚在一起，且满足<b>所有before关系</b>。对于组号-1的记录，则只满足before关系即可。

难度：hard

解法：这题有点意思，乍一看好像很简单，实际做发现有点麻烦。有before关系，肯定会想到<b>拓扑排序</b>。拓扑排序因为可能存在各种分叉，多头多尾，但有一点是肯定的。如果我们给每个点记录下拓扑顺序`top[i]`，那么如果`top[i]<top[j]`，则任何有效的顺序里，<b>i一定在j前面</b>。所以，可以按`(group[i],top[i])`二维排序。拓扑排序的具体做法就不说了，也属于<b>必知必会的算法</b>。唯一要注意的，就是对-1的处理。不能把“-1”视为一组，而应该每个-1的元素都作为<b>单独一组</b>。比如可以用`-2,-3,...`这样处理。

<hr>

1207 Unique Number of Occurrences

题意：给定数组arr，请统计每个值出现的<b>次数</b>是否<>都不相同</b>。

难度：easy

解法：水题，按题意进行<b>统计</b>即可。

<hr>

1208 Get Equal Substrings Within Budget

题意：给定字符串s和t，长度相同。如果`s[i]`变为`t[i]`的代价为`|s[i]-t[i]|`，请求出最长的一个子串`s[i:j+1]`，使其变为`t[i:j+1]`的代价不超过`maxCost`。

难度：medium

解法：用双指针，<b>滑动窗口</b>思路。<b>i前、j后</b>，i往前移动，如果总代价超过maxCost，则j前进。如此，记录尽可能<b>接近但是不超过</b>`maxCost`的最长子串。总代价`O(n)`。

<hr>

1209 Remove All Adjacent Duplicates in String II

题意：给定字符串s和整数k。如果s中存在<b>连续k个重复字符</b>，则删除。删除后，前后的子串连在一起。持续删除，直到不存在为止。

难度：medium

解法：用<b>栈</b>处理。注意<b>判断k重复</b>的写法，要保证`O(1)`代价，这样总代价才是`O(n)`，否则就弄成`O(nk)`了。可以用一个<b>计数</b>，表示当前<b>栈顶元素的重复次数</b>。

<hr>

1213 Intersection of Three Sorted Arrays

题意：给定有序数组arr1、arr2、arr3，请求出在三个数组都出现过的元素。

难度：easy

解法：付费题。用<b>三指针</b>，各自前进，只有三个指针都<b>指向同一值</b>，才放入结果中。

<hr>

1214 Two Sum BSTs

题意：给定两个BST，t1和t2。请判断是否存在两树<b>各一个节点</b>，使得节点和为target。

难度：medium

解法：付费题。如果你把其中一个树的值<b>存入哈希表</b>，当然效率会更高。但如果不允许用<b>额外存储</b>的话，也可以<b>遍历t1</b>，然后针对每个`t1.val`，在t2中查找`target-t1.val`，这样的代价就是`O(n1*log(n2))`。我还是觉得<b>存入哈希表</b>更简单。

<hr>

1215 Stepping Numbers

题意：一个整数如果所有相邻数位，<b>都相差1</b>，则称为<b>“跨步数”</b>。给定low和high，请返回`[low,high]`范围内所有跨步数。

难度：medium

解法：付费题。这个要求很严格，因此答案并不多，<b>直接搜索</b>。

<hr>

1217 Minimum Cost to Move Chips to The Same Position

题意：有n个硬币，第i硬币位置在`position[i]`。你需要把所有硬币移动到同一位置。如果移动+-2代价为0，移动+-1代价为1，请问<b>最小总代价</b>是多少？

难度：easy

解法：数据量很小，<b>枚举每个i位置</b>，计算总代价即可。复杂度`O(n^2)`。

<hr>

1218 Longest Arithmetic Subsequence of Given Difference

题意：给定数组arr和公差d，请找出arr中公差为d的<b>最长等差子序列</b>，返回长度。

难度：medium

解法：这题是446题的简化版，因为规定了公差的值。比如用<b>倒推</b>的方式，对于一个值`arr[i]=x`，我只需要判断`x-d`是否存在于`arr[0:i]`即可。这个是可以用哈希表，`O(1)`代价查到的。因此，可以用<b>DP思路</b>，在`O(n)`时间完成。

<hr>

1219 Path with Maximum Gold

题意：给定m x n矩阵grid，代表一个金矿。`grid[i][j]`表示对应位置的黄金，0表示没有。你可以选<b>任意起点终点</b>，不能走重复路，不能走空格子，可以<b>上下左右</b>移动。请求出能得到的<b>最大黄金量</b>。

难度：medium

解法：按照给定的规则，好像没什么特别<b>高效、优雅</b>的解法。考虑到数据量很小，而且不能走<b>重复路</b>，那就直接<b>DFS搜索</b>吧。对于<b>每个非0的位置</b>，都作为起点，执行搜索。总代价可以认为是`O((nm)^2)`。

<hr>

1221 Split a String in Balanced Strings

题意：给定一个LR字符串s，如果L和R个数相同，则称为<b>“平衡串”</b>，请将s分为尽可能多的平衡子串，返回<b>最大个数</b>。

难度：easy

解法：用一个<b>计数cc</b>统计一下`R-L`的个数即可，每次遇到`cc=0`，就可以分一次。

<hr>

1222 Queens That Can Attack the King

题意：给定国际象棋棋盘，有一个白方国王，多个黑方皇后。按照规则，请求出可以攻击国王的所有皇后。皇后可以横、竖、斜走，<b>不能穿过棋子</b>。

难度：medium

解法：按照象棋规则判断即可。从<b>国王位置</b>出发，往<b>8个方向</b>检查。

<hr>

1223 Dice Roll Simulation

题意：有一个色子，可以摇出1~6。如果规定数字i不能连续出现`rollMax[i]`次，请问长度n的<b>不同结果</b>有多少种？结果模`1e9+7`返回。

难度：hard

解法：一般这种组合数学题，限制条件都会非常小，比如<b>“连续3次”、“相邻的”</b>之类。这次<b>连续出现的次数</b>，最多是15次。确实难，但总体思路肯定还是<b>DP</b>。那么，我们还是考虑最后几次出现的是什么，而且我只关心<b>最后一次连续出现的是几</b>。因此，DP状态可以设计成`dp[i][j][k]`表示<b>长度为i的序列，最后出现的是j，且j连续了k次</b>。剩下就不讲了，明白这个思路，DP方程就不难写了。总代价当然是`O(n^2*rollMax)`。

<hr>

1227 Airplane Seat Assignment Probability

题意：有n个人，n个座位。第1人忘了票，随便找了座位。对于后面每个人，如果座位被别人占了，就随便找个座位；否则，就坐自己的座位。请求出<b>第n人</b>能坐到<b>第n位</b>的概率。

难度：medium

解法：神奇的数学题，而且一看就有种<b>纯智力题</b>的感觉。而且这题n还很大，需要一个不超过`O(n)`的解法。我们试试<b>数学解法</b>。第1人有1/n概率，坐1位，则<b>所有人都归位</b>。有(n-1)/n概率坐错位，比如做了i位，则第`2~i-1`都归位。第i人从`{1}+{i+1,i+2,...,n}里随机选一个`。那么我们定义问题为`f(n)`，则`f(n)=(1+sum(f(n-i+1)))/n`。式子变形一下，递推求和吧。总代价`O(n)`。<b>难怪是medium</b>，就是考验你<b>有没有耐心</b>做一下数学推导。

<hr>

1228 Missing Number In Arithmetic Progression

题意：给定数组arr，是个<b>等差数列</b>。其中有一个元素被<b>删除</b>了，请找出这个值。

难度：easy

解法：付费题。水题。

<hr>

1229 Meeting Scheduler

题意：有两个人开会，需要约个时间，时长为`duration`。给定两人的空闲时段`slots1、slots2`，请求出最早的<b>共同空闲时间</b>。

难度：medium

解法：付费题。其实就是区间<b>求交集</b>，对于两边的区间`[x1,y1]`和`[x2,y2]`，才用双指针，不断前移的办法。<b>一边移动，一边求交集。</b>只要某段<b>交集长度</b>达到`duration`，就可以了。

<hr>

1230 Toss Strange Coins

题意：有n个硬币，每个硬币朝上的概率为`prob[i]`。请求出扔所有硬币1次，恰好有target个朝上的概率。

难度：medium

解法：付费题。既然每个硬币的概率都给出了，那就按<b>DP思路</b>，直接计算。定义`dp[i][j]`表示<b>前i个硬币有j个朝上</b>的概率，两层循环算出。总代价`O(n^2)`。注意<b>精度</b>。

<hr>

1232 Check If It Is a Straight Line

题意：二维平面给定一些点，请判断是否<b>共线</b>。

难度：easy

解法：虽然难度easy，也不要用`O(n^2)`枚举的方法。计算斜率，用`(x,y)`元组的方式化为<b>最简分数</b>。用<b>哈希表</b>记录斜率，看<b>有没有多个值</b>。有的话，就<b>不共线</b>。总代价`O(n)`。

<hr>

1233 Remove Sub-Folders from the Filesystem

题意：给定一些形如`/a/b/c`的目录。如果其中目录x是目录y的<b>子目录</b>，则删除x。

难度：medium

解法：不要直接用子串匹配。可以给每个目录加一个“/”，再做<b>子串匹配</b>。

<hr>

1236 Web Crawler

题意：<b>网络爬虫</b>。利用一个<b>起始URL和HTML解析器</b>，写一个简易爬虫。

难度：medium

解法：付费题。这基本算是<b>系统设计题</b>了。作为爬虫，<b>最最最基础</b>的思路就是<b>HTML解析、BFS广度搜索、URL记录和去重</b>。实现这些，就算及格了。

<hr>

1237 Find Positive Integer Solution for a Given Equation

题意：给定一个内容未知的二元函数`f(x,y)`和一个值z。已知<b>函数f针对x和y</b>都单调递增。请求出所有(x,y)值，使得`f(x,y)=z`。已知x、y都在`[1,1000]`范围内。

难度：medium

解法：第一种解法，对于每个x，我都对y值进行<b>二分搜索</b>，这样的总代价是`O(nlogn)`。第二种解法，利用类似<b>Young tableau</b>结构的特点，令`x=1,y=1000`，然后向下向右走。之后会沿着`f(x,y)=z`的边界一直走，找到所有答案。总代价是`O(n+n)=O(n)`。

<hr>

1238 Circular Permutation in Binary Representation

题意：请生成<b>n位格雷码</b>，且要求第一个元素是`start`。

难度：medium

解法：请参见89题，格雷码。用`f(n)=f(n-1)+f(n-1)[::-1]`即可。对于开头元素是`start`，执行一次<b>循环移位</b>就行了。

<hr>

1239 Maximum Length of a Concatenated String with Unique Characters

题意：给定一个字符串数组arr，请从中选出一些串<b>拼到一起</b>，使得结果不包含<b>重复字符</b>。请求出结果的最大长度。

难度：medium

解法：数据量非常小，而且字母总共就26个，<b>随便怎么处理</b>都行。你甚至可以<b>用位运算表示一切</b>。

<hr>

1243 Array Transformation

题意：给定一个数组a，在<b>每次操作</b>时，如果一个`a[i]`比左右都笑，则+1；比左右都大，则-1。两端元素则保持不变。请返回数组的<b>最终状态</b>。

难度：easy

解法：付费题。数组<b>长度和值都很小</b>，直接+1-1好像也行。

<hr>

1244 Design A Leaderboard

题意：请设计一个<b>比分牌</b>，记录各个运动员的分数。支持`add(id,score)`、`top(k)`、`reset(id)`。其中top()函数表示求出<b>比分前k</b>的运动员的<b>总分</b>。

难度：medium

解法：付费题。对于<b>加分、重置</b>操作，都可以通过哈希表`O(1)`完成，但这样做<b>前k大统计</b>会很慢。想了下，还是用`分数->[运动员ID]`这种映射，使用<b>SortedDict</b>做<b>有序映射</b>比较好。剩下就不说了，这个实现虽然<b>比较麻烦</b>，但效率至少是好的。

<hr>

1245 Tree Diameter

题意：给定用无向图表示的树，请求出树的直径，也就是其中的<b>最长路径</b>。

难度：medium

解法：付费题。<b>搜两次。</b>从任意点出发，搜出<b>最远的点x</b>。从x出发，搜出<b>最远的点y</b>。x-y的距离就是直径。

<hr>

1247 Minimum Swaps to Make Strings Equal

题意：给定同长度的字符串s1、s2，都只包含<b>字符“xy”</b>，你可以选择任意`s1[i]`和`s2[j]`交换。请求出最小交换次数，使得`s1==s2`。

难度：medium

解法：既然可以交换任何位置，就不用想复杂了。统计s1的xy个数，s2的xy个数。那么`dx=n1(x)-n2(x)`，`dy=n1(y)-n2(y)`，因为总长度相同，则`dx+dy==0`，如果<b>dx、dy奇偶性不同</b>，则s1、s2不可能相等。交换时，可以采取<b>两对一换</b>的方式，比如xx+yy，经过<b>一次交换</b>变为xy+xy。也可能剩下<b>单独一对</b>，这对则需要<b>两次交换</b>。这题有点<b>智力题</b>的感觉，略巧妙。

<hr>

1248 Count Number of Nice Subarrays

题意：给定数组nums和整数k，如果存在k个奇数，则称为<b>“好数组”</b>。请求出<b>好子数组</b>的个数。

难度：medium

解法：用哈希表，统计<b>前缀奇数个数</b>。对于x，找`mm[x-k]`即可。

<hr>

1249 Minimum Remove to Make Valid Parentheses

题意：给定一个带有“()”和字母的串s，请删除<b>最少的括号</b>，使得括号匹配。字母不用管。

难度：medium

解法：和字母毫无关系，只处理括号就行了。用一个<b>计数cc</b>处理。`cc<0`，则删除“)”。处理完之后，如果`cc>0`，则删除“)”。这<b>相当于用栈</b>处理。

<hr>

1252 Cells with Odd Values in a Matrix

题意：给定m x n矩阵，初始值是0。给定一些`(i,j)`位置，对于每个位置，给所有<b>第i行、第j列</b>都+1。注意，`[i][j]`位置要加两次。请返回最终矩阵里，<b>值为奇数的个数</b>。

难度：easy

解法：因为数据范围很小，可以直接按<b>批处理</b>的方式。把所有<b>行+1、列+1</b>记录都统计好，<b>集中处理一次</b>，然后求出每个位置的值。返回奇数的个数。还有种<b>聪明点</b>的办法，统计row和col各自的奇数个数，记为`nr、nc`，则结果为`nr*(n-nc)+(m-nr)*nc`，这个是利用<b>奇偶性</b>。这种解法的总代价为`O(n+m)`。

<hr>

1253 Reconstruct a 2-Row Binary Matrix

题意：给定一个2 x n的01矩阵。已知0行总和为`upper`，1行总和为`lower`。第i列总和为`colsum[i]`。请返回任意一种有效的矩阵，如果不存在则返回空数组。

难度：medium

解法：和为0，则是00；和为2，则是11。因此关键在于<b>01、10</b>的情况。我们可以先把<b>确定的部分</b>处理掉，只留下`colsum[i]=1`的部分。假定现在剩余的总和分别是`uu、ll`，且对应列的<b>colsum都是1</b>。那很容易了，`uu+ll`如果等于<b>剩余列数</b>，则<b>随便怎么分配</b>都行。如果不等于，则<b>无解</b>。这题算个<b>小智力题</b>。

<hr>

1254 Number of Closed Islands

题意：给定m x n矩阵表示的地形，<b>0陆1水</b>。请找出<b>完全被水包围</b>的小岛的个数。按<b>4邻接</b>处理包围。

难度：medium

解法：从所有<b>边缘的0格子</b>开始搜，这些小岛都是<b>没有包围的</b>，<b>标记为2</b>或者其他值。然后对<b>剩余的0格子</b>进行搜索，这些是包围的岛。总代价`O(mn)`。

<hr>

1255 Maximum Score Words Formed by Letters

题意：给定一个词表words，一些可选的字符letters，26个字母的分数score。请从词表中选出一些词，用letters拼成这些词，并使得到的<b>总分最大</b>。

难度：hard

解法：一看就<b>没什么好思路</b>。字符既然可以重复，我也不知道<b>选谁不选谁</b>，那就不好用<b>位操作</b>来表示了。数据量很小，尤其words的<b>个数和单词长度</b>很短。那么就从这个入手，<b>暴力搜</b>吧。

<hr>

1256 Encode Number

题意：给定一些`整数->二进制串`的编码方式，找规律<b>猜出编码规则</b>。然后把整数num进行编码。

难度：medium

解法：付费题。规则就是`2^k,k={0,1,...}`。对于每个k，都把`[0,1,...,2^k-1]`顺着写下来。如此，<b>每一段的长度</b>就是`[1,2,4,8,...]`。对于num，依次把这些部分减去，找出最后一部分里，对应的位置，就是答案。

<hr>

1257 Smallest Common Region

题意：给定一些区域名称，形如`[x0,x1,x2,...]`，表示x0包含了<b>之后所有区域</b>。给定一些这样的记录，然后给定两个区域r1、r2，请找出包含<b>r1和r2</b>的<b>最小区域</b>。

难度：medium

解法：付费题。其实就是<b>有向无环图</b>的LCA问题。你可以构建<b>反向边</b>，然后分别从`r1、r2`往回找，得到两条路径`p1、p2`。题目保证了p1、p2一定有交点，求出<b>第一个交点</b>，就是答案。

<hr>

1258 Synonymous Sentences

题意：给定一些<b>同义词关系</b>，和一个句子。请求出所有可能组成的<b>同义句子</b>。已知同义词关系是<b>对称、传递</b>的。

难度：medium

解法：付费题。把同义词表处理一下，用<b>并查集</b>把同义的都归到一起。然后针对这些词，<b>执行DFS</b>，搜出所有可能的组合。比如例子中，就是`3*2=6`种组合。

<hr>

1260 Shift 2D Grid

题意：给定m x n矩阵grid，将其视为<b>一维数组</b>，执行<b>k次循环右移</b>。

难度：easy

解法：题意没说一维数组，但实际就是这样。<b>循环移位</b>的做法就不说了。

<hr>

1261 Find Elements in a Contaminated Binary Tree

题意：给定二叉树，根节点是0，对每个位置x，如果<b>对应位置存在</b>，则左右子树分别是`2x+1`和`2x+2`。现在请实现`find(target)`函数，判断一个值是否存在于二叉树中。

难度：medium

解法：这个题目描述很莫名奇妙，所谓的“树被污染”以及-1值完全没有意义是，属于<b>无效信息</b>。对于给定值`target`，你可以确定出<b>一条唯一的LR路径</b>。沿着二叉树看看这条路径是否会在中途遇到null。如果能<b>一直走到底</b>，则表示<b>存在</b>；否则，不存在。另外，对于这题，你可以在执行过程中，把中间值都保存在<b>哈希表</b>里。这样效率会高很多。

<hr>

1262 Greatest Sum Divisible by Three

题意：给定数组nums，请返回最大的<b>子序列和</b>，使总和<b>被3整除</b>。

难度：medium

解法：所有元素非负，因此要<b>尽可能多选</b>。3的倍数都选中，看总和的余数r。对数组<b>排序</b>，如果`r=0`，全选；如果`r=1`，去掉1个1或者2个2；如果`r=2`，去掉1个2或者2个1。一道<b>无聊且繁琐</b>的题。

<hr>

1265 Print Immutable Linked List in Reverse

题意：给定一个<b>不可变的单链表</b>结构，你不能修改值，不能直接访问内容，不能修改链表指向。请将其<b>反向打印</b>出来。

难度：medium

解法：付费题。这太扯了，难道要我<b>尾递归</b>？不让尾递归，用一个<b>栈</b>，还是同理。这些都是`O(n)`空间的解法。怎么做到`O(1)`空间？

<hr>

1266 Minimum Time Visiting All Points

题意：给定二维平面一些点points，你需要从第一个出发，按顺序访问。每1s，你可以朝<b>8邻接方向</b>移动1格。请问访问完所有点，<b>最少多少秒</b>？

难度：easy

解法：对于`(x1,y1)->(x2,y2)`，花的时间就是`max(|x1-x2|,|y1-y2|)`。<b>依次计算</b>即可。

<hr>

1267 Count Servers that Communicate

题意：给定一个01矩阵grid，1表示对应位置有电脑。如果两个电脑在<b>同行或同列</b>，则可以通信。请统计能<b>参与通信</b>的电脑个数。

难度：medium

解法：针对行、列都统计电脑个数，记为`rc、cc`。那么，如果`grid[i][j]==1,rc[i]==1,cc[j]==1`，则这台电脑就是<b>孤立的</b>。统计<b>孤立的个数</b>，总数里减掉，就是答案。

<hr>

1268 Search Suggestions System

题意：给定一些条目products和一个搜索词searchWord。根据搜索的<b>每个前缀</b>，返回<b>字典序前三条</b>的匹配结果。

难度：medium

解法：和642题很像，<b>搜索提示和补全</b>。但这题<b>不需要字典树</b>。对products<b>排序</b>，然后根据前缀prefix进行二分搜索，找到<b>第一个匹配结果</b>。

<hr>

1271 Hexspeak

题意：给定整数nums，如果它的16进制表示只包含`0~1、A~F`，则将0变成O，1变成I，否则输出“ERROR”。

难度：easy

解法：付费题。水题。

<hr>

1272 Remove Interval

题意：给定一些有序且不想交的区间`intervals`，和一个要删除的区间`toBeRemoved`。请从`intervals`中删除所有和`toBeRemoved`有<b>交集</b>的部分。

难度：medium

解法：付费题。针对每个`[x,y]`，都求交就行了。如果发现已经超出`toBeRemoved`边界，就可以结束了。注意处理<b>区间分割</b>的情况。

<hr>

1273 Delete Tree Nodes

题意：有一棵树，根节点在0位置，值用`value[i]`表示，父节点用`parent[i]`表示。请从根节点出发，删除所有子树和为0的子树，返回剩余的节点个数。

难度：medium

解法：付费题。其实你不用真的构建一棵树，可以用拓扑排序的思路，执行一个<b>反向的拓扑排序</b>。从叶节点开始，以`parent`作为<b>边集</b>。不断找入度为0的点，<b>执行BFS</b>。执行的过程中，总是把当前度为0的节点x，把`sum(x)`累加到`sum(parent[x])`里去，这样子树和就能<b>一层层往上传递</b>。当然，这题如果<b>用DFS递归方式写</b>，代码<b>更易读</b>，思路也基本相同。

<hr>

1275 Find Winner on a Tic Tac Toe Game

题意：给定XO标记的<b>井字棋棋盘</b>，判断A和B谁赢了，或者平手。

难度：easy

解法：水题，规则就不说了。

<hr>

1276 Number of Burgers with No Waste of Ingredients

题意：大汉堡要4番茄1芝士，小汉堡要2番茄1芝士。请返回<b>大小汉堡个数</b>，使得材料都用完。如果做不到，则返回`[]`。

难度：medium

解法：这是初中算数题吧，<b>二元一次方程组</b>的整数解。

<hr>

1277 Count Square Submatrices with All Ones

题意：给定m x n的01矩阵，统计有多少个<b>子方阵</b>全部由1组成。

难度：medium

解法：对于每个位置`grid[i][j]`，我都考虑以它为<n>右下角，我往左上</b>能延伸几格。这就取决于`grid[i-1][j-1]`的情况，以及`grid[i][j]`向上、向左的<b>连续1个数</b>。因此，可以用<b>DP思路</b>处理。`dp[i][j]=min(dp[i-1][j-1]+1,up[i][j],left[i][j])`，如果`grid[i][j]`本身是0，则这个位置的dp<b>直接清零</b>。最终答案是`sum(dp)`。横竖方向的预计算，代价都是`O(n^2)`。枚举每个位置的代价是`O(1)`，因此总代价是`O(n^2)`。不过我以前写的是<b>子矩阵求和</b>的解法，代价是`O(n^3)`的，勉强也能接受。

<hr>

1281 Subtract the Product and Sum of Digits of an Integer

题意：给定整数nums，求<b>数位乘积</b>和<b>数位求和</b>的差。

难度：easy

解法：水题。

<hr>

1282 Group the People Given the Group Size They Belong To

题意：有n个人，编号`0~n-1`。已知这些人被分成了几个组，你只知道每个人所属<b>小组的人数`groupSizes[i]`</b>，但不知道<b>谁在哪组</b>。请求出一组可能的分组方式。

难度：medium

解法：比如有个人所在的组，有3个人。那么如果<b>有7个人都在这样3人小组</b>，这说明什么？说明至少有`ceil(7/3)=3`个这样的小组。按这个逻辑，处理一下分组。题目倒是不难，只要想清楚这个逻辑就搞定了，总代价`O(n)`。

<hr>

1283 Find the Smallest Divisor Given a Threshold

题意：给定数组nums和值threshold。请把所有元素都除以一个数d，使得`sum(nums/d)<=threshold`。请返回<b>最小的d</b>。

难度：medium

解法：思路非常直白，<b>二分搜索</b>。总代价`O(nlog(int))`。

<hr>

1284 Minimum Number of Flips to Convert Binary Matrix to Zero Matrix

题意：给定m x n的01矩阵mat，每次允许选任意`(i,j)`位置反转，同时<b>上下左右的邻居</b>位置也会反转。对于边缘和角落，则只反转<b>界内的邻居</b>。请问最少经过多少步，能把mat变为全0？如果不可能，则返回-1。

难度：hard

解法：乍一想，没有很明确的思路。怎么保证<b>全变成0</b>？看数据量，m、n都<b>非常小</b>，而且是01矩阵，这就可以用<b>位运算</b>进行压缩了。既然如此，我们把整个矩阵的状态，用`m*n`位二进制数来表示，也就是一个int。然后对这些int值，<b>执行BFS</b>，搜出到达0状态的<b>最小步数</b>。如果搜索结束还找不到0状态，就返回-1。你看这种<b>一看就很难</b>的题，如果在<b>数据量</b>上没有文章可做，那就是真的难了。总代价`O(2^(mn))`，纯粹的<b>暴力搜索</b>。

<hr>

1286 Iterator for Combination

题意：给定n个不同字符，请输出长度为k的<b>组合</b>种类。每个组合都按<b>字典序</b>排列。现在请按如上规则，设计一个迭代器，可以不断返回<b>“下一个组合”</b>。

难度：medium

解法：既然是设计迭代器，就不能用<b>DFS的方式</b>去递归了。应该借鉴<b>next permutation</b>的思路，比如例子里abc，长度为2的组合。ab之后是ac，再之后是bc。你要实现的是<b>next combination</b>，其实做法也类似，单次代价也是`O(n)`。剩下细节就不说了。

<hr>

1287 Element Appearing More Than 25% In Sorted Array

题意：给定有序数组arr，有一个值出现<b>超过了1/4</b>，请找出这个值。

难度：easy

解法：水题，直接统计。

<hr>

1288 Remove Covered Intervals

题意：给定一些`[x,y]`形式的区间，请删除其中<b>被其他区间包含</b>的区间。返回<b>剩余区间个数</b>。

难度：medium

解法：按照`(+x,-y)`维度排序，对于当前元素`[x1,y1]`，总是判断下一个元素`[x2,y2]`是否被包含。如果<b>包含则去掉</b>，不包含则前进一步。注意，<b>相交和包含</b>不一样，`x1<=x2,y1>=y2`才是包含。<b>排序方式</b>也算个小技巧。

<hr>

1289 Minimum Falling Path Sum II

题意：931的变体。给定m x n矩阵，每个格子有值`grid[i][j]`。请从每行选1列，使得<b>相邻行的列</b>都不同。请求出<b>最小的总和</b>。

难度：hard

解法：DP的思路非常直白，用`dp[i][j]`表示前i行且<b>第i行选了j列</b>的总和。剩下就不细说了，显然`dp[i][j]=grid[i][j]+max(dp[i-1][k],k!=j)`。这个max操作可以通过前缀max+后缀max进行预计算，这样能保证总代价是`O(n^2)`，而不是`O(n^3)`。这个hard不合适，显然应该定为<b>medium</b>。

<hr>

1290 Convert Binary Number in a Linked List to Integer

题意：给定一个01值构成的链表，表示一个二进制数。如果最高位在<b>左边</b>，请返回这个数的<b>整数值</b>。

难度：easy

解法：水题。

<hr>

1291 Sequential Digits

题意：如果一个数的数位恰好是递增1的等差数列，称为<b>顺序数</b>。请返回`[low,high]`范围内的顺序数，结果升序输出。

难度：medium

解法：显然，顺序数的<b>个数非常少</b>，直接搜就行了。甚至可以预计算，<b>提前算好</b>。

<hr>

1292 Maximum Side Length of a Square with Sum Less than or Equal to Threshold

题意：给定m x n矩阵，求出最大的<b>子方阵</b>，使得总和不超过`threshold`。返回<b>边长</b>。

难度：medium

解法：求一个子矩阵的和，在`O(n^2)`预计算之后，可以`O(1)`代价得出。因此，我们可以`O(n^2)`代价枚举左上角，然后用`O(n)`代价枚举右下角，`O(1)`代价求和。这样，总代价就是`O(n^3)`。看了下我以前的代码，最后一步没有`O(n)`枚举，而是用了个<b>二分搜索</b>。大同小异，<b>稍微快一点</b>。

<hr>

1295 Find Numbers with Even Number of Digits

题意：给定数组nums，请求出其中<b>位数为偶数个</b>的元素个数。

难度：easy

解法：求位数用`int(floor(log10(n))+1)`，0除外。

<hr>

1296 Divide Array in Sets of K Consecutive Numbers

题意：给定数组nums，请判断是否可以将其划分为几个<b>长度为k的</b>递增1<b>等差数列</b>。

难度：medium

解法：这题思路和<b>659题</b>完全一样，就不重复了。相当于扑克牌<b>拆顺子</b>。如果按照最长顺子的原则，<b>拆法是固定的</b>。那么比如我拆出来长度为d，则d必须<b>被k整除</b>，否则就会有<b>多余元素</b>。

<hr>

1297 Maximum Number of Occurrences of a Substring

题意：给定字符串s，请找出其中出现次数最大的子串ss，要求ss中的唯一值不超过`maxLetters`次，ss长度在`[minSize,maxSize]`之间。返回ss的出现次数。

难度：medium

解法：这题的关键在于数据范围，<b>s可以很长，但ss很短</b>，最大不超过26。因此，直接<b>枚举`[minSize,maxSize]`长度的子串</b>，也可以的。除此之外，没想出特别好的办法。

<hr>

1299 Replace Elements with Greatest Element on Right Side

题意：给定数组arr，把每个位置替换为它<b>右侧的最大值</b>。对于最后一个位置，替换为-1。

难度：easy

解法：这种左右侧的最小最大值，都是类似的<b>单调栈、单调队列</b>思路。因为它有<b>单调性</b>。这题是右侧，因此我们<b>从右往左</b>遍历。这题并不需要栈或者队列，直接记录<b>后缀max</b>即可。

<hr>

1300 Sum of Mutated Array Closest to Target

题意：给定数组arr和一个值target。如果我们选定一个val值，把所有`arr[i]>=val`的值都变为val，使得`sum(arr)`最接近target。请找出这个val值，如果有多个答案，选最小的。

难度：medium

解法：很明显，这个问题有<b>单调性</b>，val不能太小也不能太大。那就<b>二分搜索</b>吧。总代价`O(nlog(int))`。

## 1301 - 1400

1302 Deepest Leaves Sum

题意：给定二叉树，请求出<b>最深叶节点</b>的和。

难度：medium

解法：很直白，按题意实现即可。

<hr>

1304 Find N Unique Integers Sum up to Zero

题意：给定n，请<b>随意构造</b>一个n元素数组，使得总和为0，且没有重复值。

难度：easy

解法：水题。

<hr>

1305 All Elements in Two Binary Search Trees

题意：给定两个BST，请返回两棵树的所有值，结果<b>升序排列</b>。

难度：medium

解法：<b>中序遍历</b>，然后做<b>归并</b>。

<hr>

1306 Jump Game III

题意：55的变体。给定数组arr，你从0位置出发。在i位置时。可以移动到`i+arr[i]`或`i-arr[i]`。请问能否到达一个arr[i]=0的位置？

难度：medium

解法：<b>BFS</b>解决。

<hr>

1309 Decrypt String from Alphabet to Integer Mapping

题意：给定编码方式，请进行<b>解码</b>。`a~i`对应`1~9`，`j~z`对应`10#~26#`。

难度：easy

解法：水题。

<hr>

1310 XOR Queries of a Subarray

题意：给定数组arr，你需要执行一些查询，每个查询形如`(i,j)`，表示对arr[i:j+1]所有元素求<b>异或</b>。

难度：medium

解法：用类似前缀和的思路，求<b>前缀异或</b>，`arr[0:j+1]^arr[0:i]`。计算前缀的代价是`O(n)`，每次查询代价`O(1)`，因此总代价是`O(n+q)`。

<hr>

1311 Get Watched Videos by Your Friends

题意：n个人，编号`0~n-1`。给定每个人的观看视频的ID列表。现在请查询某人的k度好友的视频列表。结果按照`(观看次数,字典序)`升序排列。

难度：medium

解法：这题非常麻烦，但并不难。思路是<b>无向图+BFS</b>。找出<b>k度好友</b>，统计视频列表，按题目要求进行<b>排序</b>。每一步都很明确，<b>耐心完成</b>即可。

<hr>

1312 Minimum Insertion Steps to Make a String Palindrome

题意：给定字符串s，你可以在任意位置插入任意字符。请问至少插入多少字符，能使s变成<b>回文串</b>？

难度：hard

解法：很明显是<b>DP</b>，我们考虑`dp[i][j]`为`s[i:j+1]`变为回文串的<b>最小插入次数</b>。则按照`s[i]`和`s[j]`<b>是否相等</b>来考虑，<b>两种情况</b>。剩下就不说了，这个定为hard不合适，属于<b>非常典型的DP问题</b>，medium比较好。总代价`O(n^2)`。

<hr>

1313 Decompress Run-Length Encoded List

题意：给定<b>游程码</b>编码的结果，每两个元素`[cc,val]`表示<b>连续cc个val值</b>。请进行<b>解码</b>。

难度：easy

解法：水题，把<b>例子</b>看明白就可以写了。

<hr>

1314 Matrix Block Sum

题意：给定m x n矩阵，针对每个位置`(i,j)`，求出<b>半径为k的子矩阵和</b>，注意边界。

难度：medium

解法：先计算<b>前缀和</b>，代价`O(mn)`。之后计算每个子矩阵和代价`O(1)`，总代价`O(mn)`。

<hr>

1315 Sum of Nodes with Even-Valued Grandparent

题意：给定二叉树，请求出所有<b>祖父节点值为偶数</b>的节点之和。

难度：medium

解法：这题是<b>真的无聊</b>，什么奇奇怪怪的要求。

<hr>

1317 Convert Integer to the Sum of Two No-Zero Integers

题意：给定整数n，请返回正整数`[x,y]`，使得`x+y=n`且x、y均不含<b>数字0</b>。

难度：easy

解法：水题。

<hr>

1318 Minimum Flips to Make a OR b Equal to c

题意：给定三个整数abc，请反转a、b中最少的位，使得`a|b=c`。

难度：medium

解法：如果c的位是0，则<b>ab都得是0</b>；如果c的位是1，则<b>ab有一个1就行</b>。按这个规则进行反转，统计次数。

<hr>

1319 Number of Operations to Make Network Connected

题意：n台电脑，编号`0~n-1`。给定一些网线连接`[x,y]`，表示<b>双向直连</b>。现在允许你拔掉一些网线<b>转接别处</b>，使得<b>所有电脑都连通</b>。请判断你最少需要<b>转接</b>的次数。如果不可能全连通，则返回-1。

难度：medium

解法：题目描述挺复杂，但不难看出是个<b>无向图连通分量</b>的问题。因此，用<b>并查集</b>。在不断`union()、find()`的过程中，如果发现了<b>冗余边</b>，则把冗余个数记住，比如有`nr`条。<b>冗余</b>的意思，就是`find(x)==find(y)`，已经连通了。同时，记录总共的<b>连通分量个数</b>`nc`。如果`nr>=nc-1`，则可以连通；否则，<b>边不够</b>，不能连通。总代价`O(V+E)`。

<hr>

1323 Maximum 69 Number

题意：给定一个<b>由6、9构成</b>的整数num。你可以至多修改一位，请返回能得到的最大数。

难度：easy

解法：水题。

<hr>

1324 Print Words Vertically

题意：给定一个英文句子，请把单词按<b>竖向打印</b>。每个词<b>占一列</b>，高度以<b>最长单词</b>为准。每行都去掉<b>末尾多余空格</b>。

难度：medium

解法：要求很清晰，<b>仔细实现</b>即可。

<hr>

1325 Delete Leaves With a Given Value

题意：给定二叉树和值target，请<b>持续删除</b>值为target的<b>叶节点</b>。如果<b>非叶节点变为叶节点</b>，也按同样要求处理。

难度：medium

解法：使用<b>后序遍历</b>。如果下面都<b>删光了</b>，且当前点`r.val==target`，则需要继续删除。总代价`O(n)`。

<hr>

1328 Break a Palindrome

题意：给定回文串s，请替换其中一个字符，使其<b>不再是回文串</b>，且得到的<b>字典序最小</b>。

难度：medium

解法：对于`aaaaa`这种串，你无法得到更小的结果，那就<b>在末尾变一个b</b>。如果存在某个字符大于a，那就把它改为a，但注意<b>不能是正中间</b>。比如`aabaa`，这种只能变为`aabab`。挺无聊的一题。

<hr>

1329 Sort the Matrix Diagonally

题意：给定m x n矩阵，把每条<b>对角线内</b>的元素排序。

难度：medium

解法：按题意实现即可，一条条地<b>排序</b>，然后按位置<b>填回去</b>。

<hr>

1331 Rank Transform of an Array

题意：给定数组arr，请给所有<b>唯一值</b>进行排序，<b>序号</b>从1开始。然后把每个`arr[i]`替换为<b>对应的序号</b>。

难度：easy

解法：水题。`mm=dict([(x,i+1) for i,x in enumerate(sorted(set(arr)))]); [mm[x] for x in arr]`之类的。

<hr>

1332 Remove Palindromic Subsequences

题意：给定字符串s，全部由字母ab组成。每次你可以从中删除一个<b>回文子序列</b>，请问<b>至少几次</b>能删光？

难度：easy

解法：<b>智力题</b>，如果s非空，且<b>不是回文串</b>，则答案一定是2。这太扯了，<b>纯属糊弄人</b>。

<hr>

1333 Filter Restaurants by Vegan-Friendly, Price and Distance

题意：给定一些餐馆记录，包括`(ID,评分,素食,价格,距离)`。你需要按照`(素食,价格,距离)`三维筛选，再按`(-评分,-ID)`二维排序，返回排序后的结果。

难度：medium

解法：思路简单，但<b>要求繁琐的一题</b>，思路就是先过滤再排序，按题意实现即可。

<hr>

1334 Find the City With the Smallest Number of Neighbors at a Threshold Distance

题意：给定n个城市，编号`0~n-1`。其中存在一些`[x,y,w]`的w权重<b>双向边</b>。对于一个点x，我们统计所有<b>可到达</b>且距离不超过`distanceThreshold`的点y的个数。请返回个数最小的x，如果有多个答案，选值最大的x。

难度：medium

解法：这题最大的难点在于<b>题目描述太差了</b>，不知道在讲什么。其实相当于做一个<b>带权的全最短路</b>。使用<b>Floyd算法</b>，求出最短路。然后对每个点统计<b>阈值之内的可达个数</b>，找出个数最小的一个。总代价`O(n^3)`。

<hr>

1337 The K Weakest Rows in a Matrix

题意：给定m x n的01矩阵，每行都是<b>1在左0在右</b>。请按照`(1的个数,行号i)`<b>二维排序</b>，返回前k个行号。

难度：easy

解法：按如上所说的二维排序即可。

<hr>

1339 Maximum Product of Splitted Binary Tree

题意：给定二叉树，允许删除一条边，使其分为<b>两棵树</b>。请求出能得到的两棵树<b>节点和的乘积的最大值</b>。结果模`1e9+7`返回。

难度：medium

解法：不需要真的拆开。先遍历一次，得到整棵树的总和`sm`。再遍历一次，求出当前子树和`cur`，则乘积就是`cur*(sm-cur)`。求出这个的<b>最大值</b>即可，结果取模。

<hr>

1340 Jump Game V

题意：55的变体。给定数组arr，你可以从任意位置开始，每次左右跳`1~d`步。而且，如果从i跳到j，则`arr[i]`的值必须大于i、j之间所有`arr[k]，且`arr[i]>arr[j]`。请求出你能访问的<b>最多位置个数</b>。

难度：hard

解法：题目真费解，其实意思就是你必须<b>往更低的地方跳</b>，而且中途不能<b>“越过”</b>更高的地方。我首先的思路是DP，考虑i位置的左右边界`left[i]、right[i]`，后来发现这个<b>好像不对</b>，也可能是我没想明白。改为用<b>图论+DFS</b>的思路处理，加上<b>记忆化</b>来提高效率，结果就对了。<b>建图和搜索</b>的细节就不说了，总代价`O(n^2)`。

<hr>

1342 Number of Steps to Reduce a Number to Zero

题意：给定整数num，如果偶数则/2，如果奇数则-1。求出<b>变为0</b>需要几步。

难度：easy

解法：水题。

<hr>

1343 Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold

题意：给定数组arr，请求出长度为k，均值`>=threshold`的子数组个数。

难度：medium

解法：不用平均数，改为`k*threshold`求和就行了。<b>滑动窗口，大小固定</b>，剩下不说了。

<hr>

1344 Angle Between Hands of a Clock

题意：给定<b>时和分</b>，求出两个针的夹角，取`<=180`的那个。

难度：medium

解法：这个倒是有意思，算术题。

<hr>

1346 Check If N and Its Double Exist

题意：给定数组arr，判断是否存在`arr[i]=2*arr[j]`。

难度：easy

解法：水题。

<hr>

1347 Minimum Number of Steps to Make Two Strings Anagram

题意：给定同长度字符串s、t，每次你可以改变t的任意一个字符。请问至少几次，能让s和t互为anagram。

难度：medium

解法：对s和t都进行<b>字符计数</b>。得到统计数组`cs[i]`和`ct[i]`。`cs[i]-ct[i]`相减之后，可能存在一些<b>正值和负值</b>。把其中的<b>正值加起来</b>就是答案，原因就不赘述了。

<hr>

1351 Count Negative Numbers in a Sorted Matrix

题意：给定一个<b>按行、按列</b>都降序排列的m x n矩阵，请统计<b>负数的个数</b>。请在`O(m+n)`时间完成。

难度：easy

解法：这就是<b>Young tabeau</b>。从<b>右上角</b>出发，<b>向左向下</b>寻找<b>正负边界</b>。

<hr>

1352 Product of the Last K Numbers

题意：给定一个数据流，不断输入整数。请返回<b>最近k个数据</b>的乘积。

难度：medium

解法：在不考虑数据溢出（乘法非常容易溢出）的情况下，乘除法互为<b>逆运算</b>。因此对于移出k窗口的数据，除掉就行了。添加数据，求乘积的<b>单次操作</b>都是`O(1)`的

<hr>

1356 Sort Integers by The Number of 1 Bits

题意：给定数组arr，请按照`(二进制1的个数,值)`二维进行排序。

难度：easy

解法：countOne函数的写法，也属于<b>位操作必知必会</b>了。`while x: x&=x-1; cc+=1`，剩下就是<b>元组排序</b>了。

<hr>

1357 Apply Discount Every n Orders

题意：有一个超市，有一些商品。客人来购物，有购物清单。针对<b>每第n个客人</b>，可以提供一个<b>幸运折扣</b>。根据以上这些规则，请计算每个客人的账单。

难度：medium

解法：虽然题目描述<b>非常繁琐</b>，但这题没什么思路上难度。计算价格，如果遇到<b>第kn个客人</b>，就给予折扣。除此之外，一切都是按`价格*数量`老老实实计算。

<hr>

1358 Number of Substrings Containing All Three Characters

题意：给定由abc组成的字符串s，请返回<b>至少包含abc各一次</b>的子串的个数。

难度：medium

解法：当然是<b>滑动窗口</b>。用双指针，<b>i前j后</b>。i每次<b>前进一步</b>，j则前进到<b>恰好不满足条件为止</b>。那么所有`s[k:i+1],k\in[j,i]`的子串都是不满足条件的。把这些从`n*(n+1)/2`里减去即可。当然，也可以把<b>满足条件</b>的<b>累加起来</b>，思路相同。总代价`O(n)`。

<hr>

1359 Count All Valid Pickup and Delivery Options

题意：有n个订单，分别有<b>取件P、配送D</b>两步。请求出有效的PD序列总共有多少种，要求先取件再配送，结果模`1e9+7`返回。

难度：hard

解法：这n个订单相互独立，而且也<b>不用像括号序列</b>那样“(())”匹配。那么总共有`(2n)!`种排列，因为Pi必须在Di前面，那么这n对PD，共有`2^n`种前后顺序，只有一种是对的。因此，<b>要除以`2^n`</b>。所以答案就是`(2n)!/2^n`，也不用变形了，就这么算吧。纯<b>数学题</b>，也可以算<b>智力题</b>。

<hr>

1360 Number of Days Between Two Dates

题意：给定`YYYY-MM-DD`格式的两个日期，求相差的天数。

难度：easy

解法：<b>标准库函数</b>当然能做，但这属于作弊了。自己实现的话，算算<b>闰年</b>，然后再精确到<b>月日</b>。总之，<b>还挺麻烦</b>。

<hr>

1361 Validate Binary Tree Nodes

题意：给定n个节点，编号`0~n-1`。给定每个节点的`leftChild[i]`和`rightChild[i]`。请验证组成的结构是不是一个合法的二叉树。

难度：medium

解法：这就看怎么<b>严格判断二叉树</b>了。它是棵树，只有<b>一个根</b>，没有环，每个点的出度不能超过2。那么我们统计<b>入度、出度</b>。如果<b>出度大于2</b>，则无效；如果<b>入度大于1</b>，则无效；如果入度为0的<b>个数大于1</b>，则无效；如果从入度为0的根节点访问，<b>出现环</b>，则无效；如果一次访问<b>没有覆盖所有节点</b>，则无效。<b>以上这些都没出现</b>，就是有效的二叉树。够严格吧？

<hr>

1362 Closest Divisors

题意：给定整数num，请找出最接近的两个数xy，使得`xy=num+1`或`xy=num+2`。

难度：medium

解法：管它+1还是+2了，对于`xy=n`的问题，我们都对n找一下<b>`sqrt(n)`以内的约数</b>，一个越大，另一个就越小，两者就<b>越接近</b>。

<hr>

1365 How Many Numbers Are Smaller Than the Current Number

题意：给定数组nums，对每个`nums[i]`，统计有多少个元素小于它。

难度：easy

解法：按照`(nums[i],i)`排序，得到数组a，然后对每个值，从j=0开始慢慢前进，直到`a[j][0]==a[i][0]`，则对于`nums[a[j][1]]`，共有j个元素比它小。排序代价`O(nlogn)`，扫描代价`O(n)`，总代价`O(nlogn)`。

<hr>

1366 Rank Teams by Votes

题意：有n场比赛，m个队伍。每场比赛有长度为m的排名结果。请按照`(-第1次数,-第2次数,...,-第m次数,+队伍名称)`的方式给所有队伍排名。

难度：medium

解法：题目描述得挺复杂，其实就是<b>多维排序</b>，前m维是降序排列，第m+1维是队伍名称。对每个队伍，统计获得1~m名的<b>次数</b>，得到一个<b>元组</b>。对元组进行排序。好在<b>m至多是26</b>，不会很大。注意，前面都是降序，最后一个是升序。因此，要采取`(-,-,...,-,+)`的排序方式。

<hr>

1367 Linked List in Binary Tree

题意：给定二叉树root和链表head，请判断树中是否存在一条<b>从上到下</b>的路径（不一定从根到叶），使得路径上的值恰好和链表完全相同。

难度：medium

解法：就在树上采取<b>搜索+回溯</b>方式，和链表进行逐个匹配。当然，这个代码虽然很好写，效率却不高，总代价是`O(nm)`。

<hr>

1370 Increasing Decreasing String

题意：给定字符串，不知道作者要表达什么。看例子吧，输入`aaaabbbbcccc`，输出`abccbaabccba`。

难度：easy

解法：题目完全<b>不知所云</b>。例子的意思是，<b>从小到大，从大到小</b>，如此往复。用一个<b>SortedDict</b>统计，然后交替顺序遍历即可。

<hr>

1371 Find the Longest Substring Containing Vowels in Even Counts

题意：给定字符串s，请找出包含aeioum每个字符<b>个数都是偶数</b>的最长子串。

难度：medium

解法：这个不需要滑动窗口。我们可以用<b>01表示偶奇</b>，那么<b>5位二进制</b>就可以表示aeiou的奇偶性了。因此，我进行前缀统计，针对每个位置i，我都统计`s[0:i+1]`对应的<b>位掩码</b>。同时，我用哈希表记录某个位掩码bm的<b>首次出现位置j</b>。则s[j+1:i+1]就是满足要求的子串，长度位`i-j`。针对所有这种情况，取max就是最终答案。这题的关键在于<b>位运算</b>。总代价`O(n)`。

<hr>

1372 Longest ZigZag Path in a Binary Tree

题意：给定二叉树，可以从任意点出发，<b>向下走</b>。请求出最长的折线路径长度，要求必须<b>左右或右左交替</b>。路径长度等于<b>节点数-1</b>。

难度：medium

解法：<b>递归遍历</b>二叉树。遍历时，可以把上一步的方向，用0左1右的方式记下来。这样，你下一步就可以<b>改变方向+延续长度</b>了。如果<b>同方向</b>，比如左左，那长度就要<b>重置为1</b>。

<hr>

1374 Generate a String With Characters That Have Odd Counts

题意：给定n，请生成一个<b>`a~z`组成的</b>长度n字符串。要求每种字符个数都是奇数个。

难度：easy

解法：n为奇数就`aaaaa`，n为偶数就`aaaaab`。<b>随便弄，都行。</b>看了下页面上的<b>“hint”</b>，竟然跟我这个一模一样，我也是服了。

<hr>

1375 Number of Times Binary String Is Prefix-Aligned

题意：给定一个长度为n的01数组，开始都是0。现在按一个`flips[i]`序列，第i次时反转`flips[i]`位置。请统计出<b>前缀对齐</b>的次数，前缀对齐是指所有1<b>都在左边</b>，所有0<b>都在右边</b>。

难度：medium

解法：脑子里<b>形象思维</b>很容易想，类似`11111000000`这种称为<b>前缀对齐</b>。那我们关心的肯定是`11011000000`这种情况，我反转一个0，<b>中间就连起来了</b>。因此，可以用<b>区间记录、合并</b>的方式来处理。比如`[1,1],[3,7]`，我反转2位，则变成了`[1,7]`。因此，判断对齐的条件，就是区间数为1且左端点在1位置。区间处理的过程稍麻烦，不细说了。还有一种解法，是<b>树状数组</b>。我对<b>单点</b>执行+1，然后对<b>总体</b>求和，得到sm。那么如果我<b>对`[1:sm]`求和也等于sm</b>，这就说明这段全都是1。这其中每个操作都是`O(logn)`，因此总代价`O(nlogn)`。相比之下，树状数组的解法<b>非常直观</b>，唯一难点就是要会用这个结构。

<hr>

1376 Time Needed to Inform All Employees

题意：公司有n个人，编号`0~n-1`。每个人的直属上司是`manager[i]`。公司老大只有1人，管理层级是个<b>树形结构</b>。现在需要传达一个紧急消息，层层下达。已知第i人需要`informTime[i]`时间来传达到所有下属。请问，<b>所有人</b>都知道消息，<b>至少</b>要多少时间？

难度：medium

解法：首先构建出这棵树，<b>从上到下</b>。从<b>根节点</b>开始，求出<b>根到叶</b>的<b>最大路径和</b>，就是答案。总代价`O(n)`。

<hr>

1379 Find a Corresponding Node of a Binary Tree in a Clone of That Tree

题意：给定一棵树`original`和它的拷贝`cloned`。给定原树里的一个节点`target`，请找出拷贝树里的对应节点。

难度：easy

解法：这个方法倒是很多，可以通过搜索`target`对应的<b>路径</b>，然后在`cloned`中走出对应的路径。这样的话，即使树里存在重复值，也无所谓。因为<b>路径是不可能重复的</b>。

<hr>

1380 Lucky Numbers in a Matrix

题意：给定m x n矩阵，请找出所有<b>幸运数</b>。幸运数的定义是在<b>本行最小且本列最大</b>。

难度：easy

解法：统计每行的最小值、每列的最大值，然后用`grid[i][j]`和两者比较即可。总代价`O(mn)`。

<hr>

1381 Design a Stack With Increment Operation

题意：设计一个栈，除了普通栈的功能外，还可以对<b>栈底的k个元素</b>都+val。

难度：medium

解法：首先，当然要用一个栈。其次就是+val这个操作，我们可以保持一个<b>inc数组</b>，大小为maxSize，初始为0。那么`inc[i]`表示栈底的<b>连续i个元素</b>的<b>累加值</b>。当我在i位置出栈时，出栈的值要加上`inc[i]`。同时，我还要把`inc[i]`的值，累加到`inc[i-1]`去。这样，所有操作都可以保证`O(1)`代价。还有一种思路，<b>比这更高效</b>。既然是累加，那我在`push(x)`的时候，把这个push操作拆分为`inc[i]+=x`和`inc[i-1]-=x`两个操作，这样，我就不需要保存这个<b>inc数组</b>了，可以直接把<b>累加信息</b>也存在栈里。我以前的代码，就是这么做的。

<hr>

1382 Balance a Binary Search Tree

题意：给定BST，请返回具有<b>相同的值</b>，但<b>结构平衡</b>的BST。平衡的定义是，任何左右子树的<b>高度差不超过1</b>。

难度：medium

解法：你可以分两步做。首先中序遍历，得到<b>有序数组</b>。然后用<b>重建平衡树</b>的思路，处理数组得到一个新树。好像还有一些奇奇怪怪的脑洞解法，我选择<b>直观且效率OK</b>的做法。

<hr>

1385 Find the Distance Value Between Two Arrays

题意：给定数组arr1、arr2和整数d，请求出`arr1[i]`的个数，使得不存在`|arr1[i]-arr2[j]|<=d`。

难度：easy

解法：可以对arr1、arr2都<b>排序</b>，然后用类似<b>有序归并</b>的做法，使得`arr1[i]`和`arr2[j]`尽量接近。对每个`arr1[i]`，判断是否有`arr2[j]`的距离不超过d。总代价`O(nlogn)`。也可以对arr2排序，然后针对`arr1[i]`的值<b>二分搜索</b>，总代价还是`O(nlogn)`。

<hr>

1386 Cinema Seat Allocation

题意：电影院，有<b>n行10列</b>的座位。每行按照`3+4+3`分布。给定一些i行j列位置，这些已经被预定了。请问剩余位置能容纳多少个<b>4或者2+2的连续位置</b>？

难度：medium

解法：题目的<b>英语水平实在堪忧</b>，话讲得模棱两可，云里雾里。方法倒是很多。比如<b>10位2进制</b>表示1排，搞一些<b>位操作</b>。那么我遇到1，就`>>1`；遇到0，我就尝试`&1111`。如果结果是0，表示有4个空位；如果结果非0，则表示其中有位置被占了。如果有4个空位，我就`>>4`判断下4位；如果没有，我就`>>1`继续判断下一位。对了，还有个<b>更懒</b>的办法，你可以直接把<b>1024种可能</b>的<b>4位置数</b>都算好，直接查就行。这算是<b>预计算，打表</b>。总代价`O(n)`。

<hr>

1387 Sort Integers by The Power Value

题意：给定整数x，定义它的力量为<b>x变换为1</b>的步数。变换规则是，奇数则`3x+1`，偶数则`x/2`。请把`[lo,hi]`范围所有整数按`(力量,值)`升序排列，返回第k个。

难度：medium

解法：没什么特别的解法，lo、hi的<b>范围很小</b>，可以<b>按规则</b>求出每个数的力量，进行排序。总代价就算`O((hi-lo)*log(hi-lo))`吧。

<hr>

1389 Create Target Array in the Given Order

题意：给定数组nums和index，从一个空数组开始，依次把`nums[i]`插入到`index[i]`的位置。

难度：easy

解法：也不用想什么优化，<b>照做就行了</b>。

<hr>

1390 Four Divisors

题意：给定数组nums，请求出约数<b>恰好4个</b>的元素的<b>约数之和</b>。

难度：medium

解法：约数4个，其实就是<b>两个不同质数</b>的乘积，或者<b>质数的立方</b>。你可以在数据范围内求出所有质数，然后<b>枚举可能的乘积和立方</b>，存入哈希表。也可以对每个nums[i]进行判断。两种方法<b>都不会超时</b>。个人觉得<b>预计算</b>的方式更好，因为给定范围内，结果并不会很多。

<hr>

1391 Check if There is a Valid Path in a Grid

题意：玩过接水管游戏吗？一个格子里面有<b>一节水管</b>，你需要在一个m x n矩阵grid里，找出从`(0,0)`到`(m-1,n-1)`的一条路径。1~6值，分别代表<b>左右、上下、左下、右下、左上、右上</b>的管子方向。

难度：medium

解法：这题有意思，因为接水管就是这么设计的，<b>很形象</b>。这题是图论，关键在于怎么<b>构建图</b>。比如`(i,j)`位置是左上，那么可以看看`(i,j-1)`的管子是不是右，`(i-1,j)`的管子是不是下。草稿纸上画一下，把这个<b>邻接关系</b>想明白。剩下的就是从起点到终点做<b>搜索</b>了。为了处理这个邻接关系，<b>实现还是很麻烦的</b>。总代价`O(mn)`。

<hr>

1394 Find Lucky Integer in an Array

题意：给定数组arr，如果一个值x的出现频率恰好等于x，称为<b>幸运数</b>。请求出最大的幸运数，不存在则返回-1。

难度：easy

解法：<b>哈希计数</b>即可。

<hr>

1395 Count Number of Teams

题意：给定数组nums，请找出三元组`(i,j,k),i<j<k`的个数，使得对应的nums值<b>严格递增或者递减</b>。

难度：medium

解法：可以用<b>DP思路</b>。要找出长度为3的<b>递增序列</b>，那么我可以定义`dp[i][j]`为长度为`i+1`的递增序列，且最后元素取`nums[j]`的个数。那么如果`nums[j]>nums[k]`，则`dp[i][j]+=dp[i-1][k]`。i的取值是012，枚举jk两个维度，因此总代价是`O(n^2)`。至于递减序列，可以把<b>数组反转</b>，用同样方法处理。

<hr>

1396 Design Underground System

题意：请设计一个数据结构，记录乘客从x站上车，到y站下车的时刻tx、ty。并通过乘客的记录，统计从x站到y站的<b>平均耗时</b>。

难度：medium

解法：注意，这不是个<b>图论题</b>。就把(x,y)作为一个精确的<b>哈希key</b>，求和，算平均就行了。题目<b>描述太复杂了</b>，容易让人以为这题很难，其实不难。

<hr>

1399 Count Largest Group

题意：给定`1~n`，请按<b>数位之和</b>进行分组。求出有<b>几个组</b>的元素<b>个数最多</b>。

难度：easy

解法：按题意实现即可，描述很清晰。也就是求<b>最大值的频率</b>。

<hr>

1400 Construct K Palindrome Strings

题意：给定字符串s和整数k，请判断能否用s的所有字符，组成k个<b>非空回文串</b>。s的字符顺序可<b>任意调整</b>。

难度：medium

解法：这肯定是个<b>智力题</b>，但不是一瞬间就能想到。首先，`k>n`肯定无解。然后，如果<b>字符奇数个oc</b>的情况很多，那么<b>正中间放不下</b>，必然出现不是回文串的情况。<b>就这两条，没了。</b>证明过程有点麻烦，评论区里有很长的讲解。总代价`O(n)`。

## 1401 - 1500

1401 Circle and Rectangle Overlapping

题意：给定一个圆的<b>圆心和半径</b>，一个和xy轴对齐的矩形的<b>左下、右上</b>。请判断两者是否<b>相交</b>。

难度：medium

解法：形象上很好理解，但<b>数学上</b>怎么定义相交？矩形内存在一个点，到<b>圆心</b>的距离小于<b>半径</b>。其实别想太复杂，你按照圆心`(rx,ry)`的位置，画个<b>`(rx+-r,ry+-r)`的十字</b>。如果相交，十字的四个点，<b>必有一个</b>在矩形内。这是我能想到的最简单的方法。

<hr>

1402 Reducing Dishes

题意：给定n道菜的满意度`satisfaction[i]`，你可以从中任选并调整顺序。按照`1,2,3,...`依次<b>相乘求和</b>。请求出能得到的最大满意度之和。

难度：hard

解法：这题的难点在于<b>读懂题目</b>，不知道在讲什么。题目本身很简单，用<b>贪心思路</b>就可以解决。对数组<b>排序</b>，那么如果我要<b>选k个菜</b>，当然应该是<b>后k个</b>，因为满意度最大。如果没想明白这点，可能会用<b>DP</b>解决。这题完全不符合hard难度。总代价`O(nlogn)`。

<hr>

1403 Minimum Subsequence in Non-Increasing Order

题意：给定数组，选出部分元素，使得选出元素<b>个数最少</b>，且`选出总和>未选的总和`。

难度：easy

解法：题目描述太啰嗦了，其实就是<b>降序排列</b>，累加直到<b>超过总和一半</b>为止。总代价`O(nlogn)`。

<hr>

1404 Number of Steps to Reduce a Number in Binary Representation to One

题意：给定二进制字符串表示的整数s，偶数则除/2，奇数则+1。请问多少步能变成1？

难度：medium

解法：规则很明确，不过这次可以是一个500位的大数。我们考虑一些例子，比如`101000`，其实<b>每个1需要多少步</b>，是可以一次性算出的。比如`1000`需要3步变成`1`，再1步变成`10`。这样算起来会<b>快很多</b>。

<hr>

1405 Longest Happy String

题意：我们定义一种<b>快乐串</b>。由字母abc组成，且不含`aaa、bbb、ccc`，而且a、b、c的个数至多是na、nb、nc个。现在给定na、nb、nc，请求出最长的快乐串，返回任意一个即可。不存在则返回空串。

难度：medium

解法：字符只有3种，因此<b>枚举的代价</b>并不大。可以按照<b>取个数最多的字符</b>为第一原则，<b>不能3连</b>为第二原则。毕竟只有abc三种字母，不用<b>最大堆</b>，直接枚举也可以的。如果遇到<b>必须3连</b>的情况，则表示<b>无解</b>。

<hr>

1406 Stone Game III

题意：877的变体。有n个石头放一排，价值为`stoneValue[i]`。两人轮流从左边，每次拿1~3个石头，最终<b>总价值高</b>的人获胜。请判断最终谁胜利，还是平局？

难度：hard

解法：这个<b>DP关系</b>还是挺容易想的，我们定义dp[i]表示stone[0:i+1]的<b>最大价值</b>。那么`dp[i]=max(sum(stone[0:i-j])-dp[i-j-1]+sum(stone[i-j:i+1])),j=[0,1,2]`。注意那个`sum(...)-dp[...]`的写法，这是<b>两人交替拿</b>的关键思路。因为能拿的个数是1~3，相当于`O(1)`，因此总代价`O(n)`。对了，还要注意这个写法<b>必须用反推，不能正推</b>。这样才能保证开局是<b>Alice先拿</b>，我上面那个写法其实不对。<b>正推反推</b>这点，我倒是经常忘。

<hr>

1408 String Matching in an Array

题意：给定词表words，请找出其中是<b>其他元素子串</b>的元素。

难度：easy

解法：数据量很小，直接<b>枚举判断</b>即可。先<b>按长度排序</b>，可以减少一半工作量。

<hr>

1409 Queries on a Permutation With Key

题意：给定一个排列，初始是`1,2,3,...,m`。有n次操作，对应每次操作的x值，你需要把排列里x的位置i找到，放入结果。并把x值移动到<b>排列开头</b>。返回n次操作的<b>i数组</b>。

难度：medium

解法：题目很费解，看了两遍才明白。似乎很难找到一个所有操作都`O(1)`的解法。如果用<b>哈希表</b>记录每个位置，则移动元素会导致`O(n)`的更新代价。如果用<b>链表</b>来保存排列，则移动变成了`O(1)`，但查找代价是`O(n)`。以本题数据量，`O(n^2)`的总代价可以接受。那就随便搞搞，直接用<b>数组</b>算了。

<hr>

1410 HTML Entity Parser

题意：给定HTML文本，请实现对其中<b>转义字符</b>的解析，比如`&quot;`之类的。

难度：medium

解法：<b>字符串题</b>，没什么好办法，只能小心实现。注意<b>边界case</b>。

<hr>

1411 Number of Ways to Paint N × 3 Grid

题意：有n x 3个格子，需要用<b>红黄绿</b>涂色。已知相邻格子都不能同色，请问总共多少种涂法？结果模`1e9+7`返回。

难度：hard

解法：3格3种颜色，共有`3^3=27`种做法。我们针对相邻的`27*27`种可能，判断<b>哪些允许，哪些不允许</b>。然后用<b>DP思路</b>求和即可。因为只关心上一步的状态，空间可以优化成`O(1)`。总代价`O(n)`。

<hr>

1413 Minimum Value to Get Positive Step by Step Sum

题意：给定数组nums，你可以选定一个值x，用x<b>依次累加</b>nums中的元素。要求得到的和必须始终大于0。请返回<b>最小的x</b>。

难度：easy

解法：前缀和<b>求min</b>，返回1-min即可。当然，这题的描述很难看懂，看例子才明白。

<hr>

1414 Find the Minimum Number of Fibonacci Numbers Whose Sum Is K

题意：斐波那契数，`1,1,2,3,5,8,...`。给定k，请找出最少的斐波那契数，求和等于k。每个数可以重复使用。

难度：medium

解法：那就是以<b>Fibonacci数列</b>为物品的<b>完全背包问题</b>，按标准做法处理即可。比如有n个物品（k以内的），则总代价`O(nk)`。

<hr>

1415 The k-th Lexicographical String of All Happy Strings of Length n

题意：给定字符串，如果由abc组成，且相邻元素都不相同，则称为<b>快乐串</b>。请返回长度为n的字典序第k的快乐串。如果不够k个，则返回空串。

难度：medium

解法：思路上，类似<b>数位DP</b>的做法。我总是考虑<b>第i位是j</b>的个数有多少，这样转化为<b>子问题</b>。因为相邻元素不能相同，因此，n位的快乐串总共有`3*2^(n-1)`种，按这个思路，<b>从高往低递推</b>。总代价`O(n)`。

<hr>

1417 Reformat The String

题意：给定字符串s，请将其排序，使得没有<b>连续字母或者连续数字</b>。如果做不到，则返回“”。

难度：easy

解法：如果字母个数和数字个数<b>相差超过1</b>，则做不到。

<hr>

1418 Display Table of Food Orders in a Restaurant

题意：根据客人的点菜记录`(客人,桌号,菜名)`，统计每个桌子点各个菜的次数。结果按`(桌号,某菜的点菜次数,...)`形式返回，并要求带上表头。表头里写上<b>菜名</b>。

难度：medium

解法：非常具体、啰嗦、无聊的一题，<b>哈希计数</b>即可。

<hr>

1419 Minimum Number of Frogs Croaking

题意：青蛙叫，`croak`。几个青蛙一起叫，则可能出现类似`crcroaoakk`的混合情况。现在给定一个这样的序列，请判断至少有<b>几只青蛙</b>同时叫？如果序列无效，则返回-1。

难度：medium

解法：croak，相当于一个<b>顺序序列</b>。必须<b>依次完整出现</b>，才算合法。那么我可以给`c、r、o、a`都加上一个计数。`k`不需要，因为`k`就结束了。比如我遇到`c`，则`mm['c']+=1`；比如我遇到`o`，则`mm['r']-=1; mm['o']+=1`；比如我遇到`k`，则`mm['a']-=1`。如果任何计数出现了<b>-1的情况</b>，则不合法。至于青蛙个数，可以看任意时刻，<b>所有计数求和</b>的<b>最大值</b>。这就是最小的青蛙个数。最后所有<b>计数必须清零</b>，才算合法。总代价`O(n)`。

<hr>

1420 Build Array Where You Can Find The Maximum Exactly K Comparisons

题意：给定一个求数组`max_val`和`max_i`的算法，我们定义代价`cost`为<b>最大值更新</b>的次数。对于数组arr，如果`arr[i]`都在`[1,m]`范围，且arr的代价恰好为k。请求出这样的arr有多少个，结果模`1e9+7`返回。

难度：hard

解法：如果cost为k，代表从arr[0]开始，之后有k次更大的值。那么我们可以定义`dp[i][j][c]`为`arr[0:i+1]`里，<b>以j结尾，代价为c</b>的数组个数。则`dp[i][j][c]=sum(dp[i-1][1~j-1][c-1])+sum(dp[i-1][j~m][c])`。因此，总代价为`O(n*m*k*m)=O(n*m^2*k)`。给定数据量比较小，因此乘起来也<b>勉强能接受</b>。同样的思路，也可以用<b>记忆化搜索</b>实现，代码会比较易读。

<hr>

1422 Maximum Score After Splitting a String

题意：给定01字符串s，将其分为左右两部分。得分是<b>左0+右1</b>的个数。请求出最大得分。

难度：easy

解法：保持<b>c0、c1两个计数</b>，一边移动一边更新即可。

<hr>

1423 Maximum Points You Can Obtain from Cards

题意：有n张牌排成一行，分值为`cardPoints[i]`。每次你可以从<b>头或尾</b>拿一张牌，总共k张。请求出最大得分。

难度：medium

解法：首先，这个不是<b>贪心</b>。反例很容易想，像这样`[2,2,2,2,10000,1]`，拿3张。也不用想复杂的<b>DP思路</b>。我要选k张，那么一定拿的是前缀和后缀的牌，且`前缀+后缀=k`。因此，我只要枚举`k+1`种前后缀组合就行了。前后缀的计算，代价都是`O(k)`，单次枚举都是`O(1)`的，因此总代价`O(k)`可以解决。

<hr>

1424 Diagonal Traverse II

题意：498的变体。给定一个m行二维数组，不一定是矩阵，每行<b>长度可能不同</b>。请按<b>反对角线</b>的方式，<b>从左上到右下</b>遍历。返回遍历结果。

难度：medium

解法：不要真的沿对角线去枚举，因为这样会导致`O(mn)`的代价，在`1e5`的规模下，就<b>超时</b>了。可以选择对下标`(i,j)`排序，<b>排序规则是`(i+j,j)`</b>，然后按排好序的结果直接遍历。

<hr>

1426 Counting Elements

题意：给定数组arr，请找出其中x值，使得`x`和`x+1`都在数组中。

难度：easy

解法：付费题。水题。

<hr>

1427 Perform String Shifts

题意：给定字符串s，执行一些<b>循环左右移</b>的操作，返回结果。

难度：easy

解法：付费题。按照<b>左-右+</b>的方向，<b>合并</b>成一次循环移位。<b>循环移位</b>的做法就不说了。

<hr>

1428 Leftmost Column with at Least a One

题意：有一个01矩阵mat，已知每行都是<b>有序</b>的。请求出第1个>b?至少存在一个1</b>的列。你可以调用`get(i,j)`函数获取元素值，但<b>调用次数要尽量少</b>，不能超过1000次。

难度：medium

解法：付费题。因为数据上限是100，那么<b>二分的代价</b>最多就是7。因此，我对每行都执行二分，找出1的边界，总代价不会超过`100*7=700`，符合要求。总代价`O(mlogn)`。

<hr>

1429 First Unique Number

题意：设计一个<b>队列</b>结构，可以不断<b>添加数据</b>，还支持查询当前第一个<b>唯一值</b>。如果没有，则返回-1。

难度：medium

解法：付费题。很重要的一点是，数据<b>只进不出</b>。可以用<b>队列+哈希表</b>的方式配合实现。<b>队列</b>用于保持先后顺序，<b>哈希表</b>则记录已经重复的值。比如例子`[2,5,3,5,1]`，则`q={2,5,3,1},st={2,5}`。这代表2、5已经重复了，3、1还是唯一的。那么当我要查唯一值的时候，我判断当前<b>出队</b>的值，<b>是否已经重复</b>。重复，则丢弃；唯一，则成功返回。类似思路，<b>实现方式有很多种</b>，细节差异不重要。每个操作都是`O(1)`或`均摊O(1)`的。

<hr>

1430 Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree

题意：给定二叉树，节点由`0~9`组成。给定`0~9`的序列`arr`，请判断是否存在一条<b>根到叶</b>的路径，结果等于这个序列。

难度：medium

解法：付费题。可以把序列用<b>字符串</b>表示，这样方便存入哈希表。遍历二叉树，把这个序列和<b>所有根到叶序列</b>比较即可。

<hr>

1431 Kids With the Greatest Number of Candies

题意：n个小朋友，每个有`candies[i]`个糖果。你有k个糖，可以给一个小朋友。对每个i，请判断第i个小朋友得到k个糖后，能不能变成糖最多的。

难度：easy

解法：水题。

<hr>

1433 Check If a String Can Break Another String

题意：给定字符串s1、s2，请问能否重排s1、s2的字符顺序，使得所有`s1[i]>=s2[i]`，或所有`s2[i]>=s1[i]`。

难度：medium

解法：这个就不用考虑<b>田忌赛马</b>的思路了，直接对s1、s2都<b>升序排列</b>，逐个位置比较即可。满足就true，不满足就false。<b>反之亦然。</b>

<hr>

1436 Destination City

题意：有向图给定一些边，求<b>出度为0</b>的点。

难度：easy

解法：水题，翻译过来就是这个意思。

<hr>

1437 Check If All 1's Are at Least Length K Places Away

题意：给定01字符串，请判断所有1之间是否都相隔至少k个0。

难度：easy

解法：判断<b>相邻的1</b>的间隔即可。

<hr>

1438 Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit

题意：给定数组nums和值limit。请求出最长的子数组，使得子数组<b>任意两值的差</b>不超过limit。返回长度。

难度：medium

解法：<b>滑动窗口</b>，非常典型。i在前，每次前进一步；j在后，前进到恰好满足limit要求位置。统计差值是时，需要知道min、max，而且需要增删元素。因此，用<b>SortedDict</b>实现比较方便。总代价`O(nlogn)`。

<hr>

1441 Build an Array With Stack Operations

题意：你有一个栈，已知`1~n`会依次入栈，你可以决定<b>出栈操作</b>。请使用合适的出栈操作，使得得到的数组等于`target`。

难度：medium

解法：之前有道类似的题，<b>946题</b>，比这个难。因为你要判断的是<b>留下来的值</b>，不是出栈的值，因此<b>留下的值一定是递增的</b>。你可能得到`[1,3]`，但不可能得到`[3,1]`。那么，我从1~n，如果<b>等于</b>当前值，<b>就留下</b>；不等于，就丢弃。就这么简单。总代价`O(n)`。

<hr>

1442 Count Triplets That Can Form Two Arrays of Equal XOR

题意：给定数组arr，请找出`(i,j,k),i<j<=k`，使得`xor(arr[i:j])=xor(arr[j:k+1])`。

难度：medium

解法：注意下标，是`i~j-1`和`j~k`。异或函数的<b>前缀</b>是可以<b>相减</b>的。因此，我们统计所有`xor(arr[0:i+1])`，如果其中存在`xor(arr[0:i+1])=xor(arr[0:j+1])`，则表示`arr[i+1:j+1]`这段的<b>异或为0</b>。这代表什么？代表这段里<b>随便</b>分成两部分，这两部分的异或值都相等。`x^x=0`，对吧？因此，这其中存在j-i-1个划分方法。我们找到所有这样的`(i,j)`对，累加起来就是答案。总代价`O(n^2)`。这题的思维有一点难度，但代码非常简短。属于合理的<b>脑力题</b>，但不算智力题。

<hr>

1443 Minimum Time to Collect All Apples in a Tree

题意：给定一个n节点的<b>无向树</b>，部分节点上有苹果。你从0位置出发，需要收集所有苹果并<b>返回</b>0位置。走一条边的代价是1，请问最小总代价是多少？

难度：medium

解法：总数肯定是*2，因为要<b>往返</b>。我们先不管这个“2”，其实要访问的边数，就是覆盖到所有<b>包含苹果的子树</b>的边。因此，我们可以在<b>后序遍历</b>时，确定当前子树是否<b>没有苹果</b>，如果没有苹果，我就<b>不用来了</b>。那么当我进入时，我先+1；等我退出时，如果发现<b>我不该来</b>，我就-1。这样就相当于<b>我没来过</b>。最后得到的总结果`*2`，就是最终结果。实现方式有多种，但思路都是围绕<b>“后序遍历+子树是否有苹果”</b>展开的。总代价`O(n)`。

<hr>

1446 Consecutive Characters

题意：给定字符串s，请求出<b>单值子串</b>的最大长度。

难度：easy

解法：水题。

<hr>

1447 Simplified Fractions

题意：给定n，请返回分母不超过n的<b>最简真分数</b>。返回<b>顺序任意</b>。

难度：medium

解法：最简真分数，注意<b>公约数</b>问题。数据不大，<b>直接枚举</b>就行了。

<hr>

1448 Count Good Nodes in Binary Tree

题意：给定二叉树，对于节点x，如果从根到x没有比x大的值，则称为<b>好节点</b>。请统计好节点的个数。

难度：medium

解法：<b>递归遍历</b>二叉树，同时记录<b>当前路径</b>最大值，看是否超过当前节点即可。注意，是当前路径最大，<b>不是全局最大</b>。总代价`O(n)`。

<hr>

1450 Number of Students Doing Homework at a Given Time

题意：给定一些区间`[x,y]`，给定某个值t。请判断t落在几个区间内？

难度：easy

解法：水题。

<hr>

1451 Rearrange Words in a Sentence

题意：给定一个英文句子，请把单词按照长度升序排列。如果长度相同，则保持之前的先后顺序。

难度：medium

解法：按照`(len(w[i]),i)`排序即可。注意<b>首字母</b>要大写。

<hr>

1452 People Whose List of Favorite Companies Is Not a Subset of Another List

题意：给定n个人，每个人有一个喜爱公司的列表`favoriteCompanies[i]`。请找出这些列表中，不是<b>其他列表子集</b>的个数。

难度：medium

解法：你可以想到一个很直观的做法，就是<b>`O(n^2)`枚举一下</b>，都检查一遍。基本就是这样，不过你可以做两点<b>小优化</b>。第一，按<b>长度</b>升序排列，可以减少一半工作量；第二，把`list[int]`转为`set[str]`，这样效率高一点。

<hr>

1455 Check If a Word Occurs As a Prefix of Any Word in a Sentence

题意：给定英文句子sentence和一个单词word。请判断word是不是句子里某个词的<b>前缀</b>。返回第一个匹配的下标，不存在则返回-1。

难度：easy

解法：水题。

<hr>

1456 Maximum Number of Vowels in a Substring of Given Length

题意：给定字符串s和整数k，请返回k长度子串的最大元音个数。元音是`aeiou`。

难度：medium

解法：<b>滑动窗口，固定大小。</b>用一个计数cc统计元音个数即可。总代价`O(n)`。

<hr>

1457 Pseudo-Palindromic Paths in a Binary Tree

题意：给定二叉树，节点值都在1~9。我们定义<b>伪回文串</b>，为经过<b>排列</b>可变为回文串的序列。请统计所有根到叶的路径中，伪回文串的个数。

难度：medium

解法：题目定义很清晰，遍历得到所有<b>根到叶路径</b>，逐个检查一下就行了。检查的规则，就是<b>至多有一个值</b>的统计为<b>奇数</b>。总代价`O(n)`。

<hr>

1460 Make Two Arrays Equal by Reversing Subarrays

题意：给定数组arr、target，长度相同。每次你可以选择arr的任意子数组<b>反转</b>。请问能否把arr变成target？

难度：easy

解法：其实<b>随意反转</b>也就等于可以<b>随意排序</b>。比较两者`sorted()`之后<b>是否相同</b>即可。

<hr>

1461 Check If a String Contains All Binary Codes of Size K

题意：给定01串s和整数k，请判断s是否包含了所有种类的<b>长度为k的01串</b>？

难度：medium

解法：k不会很大，因此你可以直接用<b>int</b>来表示对应的值。那么在遍历s时，总是取当前<b>k窗口</b>，计算值，检查<b>哈希表</b>。如果发现哈希表达到`2^k`大小，则<b>填满了</b>。窗口移动时，计算代价都是`O(1)`的，可以通过<b>位运算</b>实现。总代价`O(n)`，需要额外的`O(k*2^k)`空间，空间开销是大头。其实可以用<b>位向量</b>代替<b>哈希表</b>，这个对于<b>连续存储</b>的效率更高，底层有<b>优化</b>。

<hr>

1462 Course Schedule IV

题意：207的变体。有n门课，编号`0~n-1`。给定一些前置关系`[x,y]`，表示x课是y课的<b>前置条件</b>。前置关系是<b>传递的</b>，表示`a->b,b->c`，则`a->c`。现在给定一些查询`[qx,qy]`，请判断qx是否为qy的前置课。

难度：medium

解法：又是选课问题。显然，你不能在每次查询时都<b>遍历整个图</b>。比如例子`a->b->c->x`和`d->e->x`，x和两边都有关系，但<b>abc和de却没关系</b>，两者不存在先后。这种怎么处理？可以给每个点设置一个<b>前置集合`st[i]`</b>。从<b>入度为0</b>（也就是最上面）的点开始执行<b>BFS</b>。当然，搜索方式<b>用BFS、DFS都行</b>。比如对于边`x->y`，那么`st[y].add(x);st[y]|=st[x]`。y的前置除了x外，还要加入x的前置，因为<b>传递关系</b>。这个过程要遍历所有边，因此总代价是`O(E)`。完成后，每个点的前置集合都算好了。针对查询，检查`st[qy]`里是否有`qx`即可。

<hr>

1463 Cherry Pickup II

题意：741的变体。给定m x n矩阵grid，表示每个格子的<b>樱桃数</b>。你在`(0,0)`和`(0,n-1)`有两个机器人摘樱桃。两个机器人每次都按照<b>行+1、列+-1或者0</b>的方式移动。如果两机器人在<b>同一格</b>，则<b>只有一个</b>摘到樱桃。请求出最终摘到的<b>最大樱桃数</b>。

难度：hard

解法：741题就是hard，这题也是，挺麻烦的。一个机器人的话，就是非常简单的<b>DP问题</b>。现在有两个，那我是不是可以把`dp[i][j]`变为`dp[i][j][k]`，表示第i行时，两机器人分别<b>在j、k位置</b>的最大樱桃数？那么`dp[i][j][k]`就和上一排的`(j-1,j,j+1)`、`(k-1,k,k+1)`去做比较了。这里要处理的特殊情况是`j==k`，这时只能加上`grid[i][j]`一次。这样的话，DP方程也搞懂了，不算很难。总代价`O(m*n^2)`。

<hr>

1464 Maximum Product of Two Elements in an Array

题意：给定数组nums，任选两个元素，求出`(nums[i]-1)*(nums[j]-1)`的最大值。

难度：easy

解法：元素都是正数，那就取<b>最大的两个</b>。

<hr>

1466 Reorder Routes to Make All Paths Lead to the City Zero

题意：有n个城市，编号`0~n-1`。整个路线组成了<b>一棵无向树</b>。现在这些路变成了<b>单向</b>，方向由`[x,y]`给定，表示`x->y`。请问你至少需要<b>改变</b>几条路的方向，能使所有城市，都能到达0城市。

难度：medium

解法：因为它是个无向树，你如果从0出发，按照<b>无向的方式</b>搜索，可以得到所有点的对应路径。那么这个路径上的所有边，都应该是<b>反着来的</b>。比如`0-7-8-5`，那么这个边就应该是`5->8->7->0`。按照这个思路，每到达一个点，都检查当前的边<b>方向是否正确</b>。如果需要反转，则计数+1。最后得到的<b>总计数</b>就是答案。这题出得挺好的，有种<b>活学活用</b>的感觉。

<hr>

1469 Find All the Lonely Nodes

题意：给定二叉树，请返回<b>孤独节点</b>。意思是这个节点的<b>父节点只有一个孩子</b>。

难度：easy

解法：付费题。按题意遍历即可，遍历时带上<b>父节点</b>。

<hr>

1470 Shuffle the Array

题意：给定长度2n的数组，按照`1,n+1,2,n+2,3,n+3,...,n,2n`进行重排。

难度：easy

解法：水题。用python可以一句话完成，`b[0::2]=a[:n];b[1::2]=a[n:]`。

<hr>

1471 The k Strongest Values in an Array

题意：给定数组arr，如果它的<b>中位数</b>是m，我们定义<b>强壮</b>的概念。如果`|arr[i]-m|>|arr[j]-m|`，则称`arr[i]`比`arr[j]`更强壮。请返回最强壮的k个元素。

难度：medium

解法：题目讲得很复杂，其实意思就是<b>离中位数最远</b>的k个元素。先求出<b>中位数m</b>，然后按`-abs(arr[i]-m)`排序就行了。求中位数可以用土办法，对数组<b>排序</b>得到。两次排序，总代价`O(nlogn)`。

<hr>

1472 Design Browser History

题意：模拟一个浏览器页面的访问。你可以访问url，前进n步，后退n步。如果当前历史没有n步，则前进到<b>最近的一页</b>。

难度：medium

解法：主要考虑的情况，就是`back()`之后，选择`visit()`一个新的页面。这样，你之前的访问历史就要清除，改为新的页面。除此之外，用一个<b>数组</b>就可以记录历史了。按题意实现即可，所有操作都是`O(1)`的。

<hr>

1474 Delete N Nodes After M Nodes of a Linked List

题意：给定单链表，每<b>跳过</b>m个节点，<b>删除</b>之后的n个节点。重复这个操作，直到末尾。末尾如果跳过数量不足m，或者删除不足n，都执行到末尾为止。

难度：easy

解法：付费题。按题意实现，注意边界case。

<hr>

1475 Final Prices With a Special Discount in a Shop

题意：给定n件商品的价格`prices[i]`。对于第i件商品，如果存在最小的`j>i,prices[j]<=prices[i]`，则可以优惠`prices[j]`；如果不存在，则保持原价。请求出每件商品的<b>优惠后价格</b>。

难度：easy

解法：保持一个<b>单调递增的栈</b>，每次遇到`arr[j]<=arr[i]`，就出栈，`arr[i]`的优惠幅度就是`arr[j]`。最终留在栈中的，就是不享受优惠的，保持原价。总代价`O(n)`。

<hr>

1476 Subrectangle Queries

题意：设计一个矩阵类，支持批量修改一个<b>子矩阵范围</b>的值为`val`，支持查询单个元素。

难度：medium

解法：这个不是<b>批量+val</b>，而是<b>批量=val</b>，因此无法用<b>二维树状数组</b>。想了半天也没找到好办法，直接暴力解法。<b>居然也过了。</b>暴力解法的批量修改就<b>真的是批量</b>，代价`O(mn)`。有什么好方法吗？

<hr>

1480 Running Sum of 1d Array

题意：给定数组nums，求<b>前缀和</b>。

难度：easy

解法：水题。

<hr>

1481 Least Number of Unique Integers after K Removals

题意：给定数组arr和整数k，从arr中移除k个元素，使得剩余的<b>唯一值最少</b>。返回唯一值个数。

难度：medium

解法：首先，进行<b>哈希计数</b>。然后按`个数`升序排列，优先移除<b>个数少的</b>。作为medium题，这题偏简单。

<hr>

1482 Minimum Number of Days to Make m Bouquets

题意：有n朵花排成一排，开花时间是`bloomDay[i]`天之后。现在需要做m束花，每束需要相邻的k朵花。请问<b>至少等多少天</b>，你才有足够的花做出m束？

难度：medium

解法：这个问题有<b>单调性</b>，如果等x天可以，则等x+1天一定也可以。可以二分搜索这个天数x。对于x天，我判断一下<b>哪些花已经开了</b>，然后统计能从中选出多少个<b>k长度的连续段</b>。如果`个数>=m`，则满足。用二分的方式找出<b>分界点</b>，就是答案。记住，<b>二分</b>的关键就是<b>单调性</b>。

<hr>

1485 Clone Binary Tree With Random Pointer

题意：给定二叉树，每个节点还带有一个<b>随机指针</b>。指针可能指向树里的一个节点，也可能指空。请对整棵树做深拷贝，并把random指针<b>对应指向</b>新树的节点。

难度：medium

解法：付费题。138题，带随机指针的链表。这题是带随机指针的二叉树。除了<b>哈希+一一映射</b>的方式，我想不出什么特别巧妙的解法了。像138题那样<b>匪夷所思的做法</b>，实在没有学习的必要。

<hr>

1486 XOR Operation in an Array

题意：给定整数x和n，求`[x,x+2,...,x+2n-2]`的异或。

难度：easy

解法：水题。

<hr>

1489 Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree

题意：给定一个<b>带权无向图</b>，请求出最小生成树的<b>关键边</b>和<b>伪关键边</b>。关键边，指的是去掉这条边，MST的权重和就会<b>变大</b>。伪关键边则是会出现在<b>某个MST中的边</b>，不一定所有MST。

难度：hard

解法：这题比较难，而且<b>非常费劲</b>。<b>关键边</b>是需要删除的，你必须删完了再做MST，判断<b>权重和</b>是否变大了。至于<b>伪关键边</b>，则是看这条边在不在MST中。你可以通过先添加这条边，然后执行MST算法（比如Kruskal算法），看得到的总和<b>是否等于最小总和</b>。如果等于，这条边就是<b>伪关键边</b>。这题的两个任务都挺麻烦，作为一道算法题，工作量过于大了。<b>耐心完成吧。</b>复杂度的话，单次<b>Kruskal算法</b>的代价是`O(E)`。因为要执行`O(E)`次，则总代价是`O(E^2)`。你如果选Prim算法也行，目的都是<b>求MST</b>。

<hr>

1490 Clone N-ary Tree

题意：给定n叉树，做一次<b>深拷贝</b>。

难度：medium

解法：付费题。<b>递归复制</b>即可。

<hr>

1491 Average Salary Excluding the Minimum and Maximum Salary

题意：给定数组，去掉一个min和max后，求平均。

难度：easy

解法：水题。

<hr>

1492 The kth Factor of n

题意：给定整数n，求出<b>升序下</b>，n的第k个约数。

难度：medium

解法：通过`O(sqrt(n))`代价，就可以求出n的所有约数，返回第k个。

<hr>

1493 Longest Subarray of 1's After Deleting One Element

题意：给定01数组nums，你需要从中删除一个元素。请求出删除后的<b>最长连续1</b>的个数。

难度：medium

解法：有两种特殊情况，一种是<b>全1</b>，返回`n-1`；一种是存在`1..101..1`这样<b>单个0</b>，返回<b>两段1</b>的长度之和。除此之外，统计<b>一段1</b>的长度即可。

<hr>

1496 Path Crossing

题意：从(0,0)出发，按照NSEW指令，分别代表<b>北南东西</b>移动1格。请判断整个路径是否存在交叉，也就是存在<b>重复访问的点</b>。

难度：easy

解法：数据量并不大，可以把<b>每一步的位置</b>算出来，<b>判重</b>就行了。
