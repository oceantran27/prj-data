#201 Bitwise AND of Numbers Range

// #201 区间按位与

描述：给定一个整数闭区间，求其所有数的按位与。

// [#201](https://leetcode.com/problems/bitwise-and-of-numbers-range/) Description: Bitwise AND of Numbers Range | LeetCode OJ

解法1：此解法很巧妙，我很欣慰。

// Solution 1: A clever solution, which took me about half an hour to figure out.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0201_bitwise-and-of-numbers-range_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0201_bitwise-and-of-numbers-range_1_AC.cpp)

<hr>

#202 Happy Number

// #202 幸福数

描述：给定一个数，不断将此数变为此数各位数字的平方和。如果能够终止于1，则称为幸福数。所以，你幸福吗？

// [#202](https://leetcode.com/problems/happy-number/) Description:

解法1：我姓朱。

// Solution 1: I'm flappy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0202_happy-number_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0202_happy-number_1_AC.cpp)

<hr>

#203 Remove Linked List Elements

// #203 去除链表元素

描述：删除链表中某特定值的所有节点。

// [#203](https://leetcode.com/problems/remove-linked-list-elements/) Description: Remove Linked List Elements | LeetCode OJ

解法1：删呗。

// Solution 1: Do it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0203_remove-linked-list-elements_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0203_remove-linked-list-elements_1_AC.cpp)

<hr>

#204 Count Primes

// #204 数质数

描述：统计小于n的质数个数。

// [#204](https://leetcode.com/problems/count-primes/) Description: Count Primes | LeetCode OJ

解法1：筛法。

// Solution 1: Sieve of Eratosthenes.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0204_count-primes_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0204_count-primes_1_AC.cpp)

<hr>

#205 Isomorphic Strings

// #205 同构字符串

描述：给定俩字符串，判断能否通过字符间的一一对应关系，把前者变成后者。

// [#205](https://leetcode.com/problems/isomorphic-strings/) Description: Isomorphic Strings | LeetCode OJ

解法1：既然是一一对应嘛，用两个哈希表就行了。

// Solution 1: Two hash map for one bijection.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0205_isomorphic-strings_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0205_isomorphic-strings_1_AC.cpp)

<hr>

#206 Reverse Linked List

// #206 反转链表

描述：如题。

// [#206](https://leetcode.com/problems/reverse-linked-list/) Description: Reverse Linked List | LeetCode OJ

解法1：要做到分分钟搞定的程度。

// Solution 1: Basic training.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0206_reverse-linked-list_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0206_reverse-linked-list_1_AC.cpp)

<hr>

#207 Course Schedule

// #207 课程表

描述：有n门课，给定一些前置课规则和一份选课列表，判断能否完成所有课程。

// [#207](https://leetcode.com/problems/course-schedule/) Description: Course Schedule | LeetCode OJ

解法1：拓扑排序。

// Solution 1: Topological sort.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0207_course-schedule_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0207_course-schedule_1_AC.cpp)

<hr>

#208 Implement Trie (Prefix Tree)

// #208 实现字典树（前缀树）

描述：实现字典树，能插入单词，能查找单词、前缀。

// [#208](https://leetcode.com/problems/implement-trie-prefix-tree/) Description: Implement Trie (Prefix Tree) | LeetCode OJ

解法1：空间申请了，就要释放。对象构造了，就要析构。反观我朱某人，许多事却都半途而废，惭愧啊。

// Solution 1: Finish what you started.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0208_implement-trie-prefix-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0208_implement-trie-prefix-tree_1_AC.cpp)

<hr>

#209 Minimum Size Subarray Sum

// #209 最短子数组和

描述：给定一个数组和一个值，找出不小于该值得最短子数组。

// [#209](https://leetcode.com/problems/minimum-size-subarray-sum/) Description: Minimum Size Subarray Sum | LeetCode OJ

解法1：俩指针搞定。

// Solution 1: Two pointers will do.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0209_minimum-size-subarray-sum_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0209_minimum-size-subarray-sum_1_AC.cpp)

<hr>

#210 Course Schedule II

// #210 课程表2

描述：和之前一样，不过这次要返回一种可行的上课顺序。

// [#210](https://leetcode.com/problems/course-schedule-ii/) Description: Course Schedule II | LeetCode OJ

解法1：拓扑排序。

// Solution 1: Topological sort.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0210_course-schedule-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0210_course-schedule-ii_1_AC.cpp)

<hr>

#211 Add and Search Word - Data structure design

// #211 添加查找单词 - 数据结构设计

描述：设计一个数据结构，能够插入单词，能够查找字符串，并支持正则表达式中的“.”单字符通配。

// [#211](https://leetcode.com/problems/add-and-search-word-data-structure-design/) Description: Add and Search Word - Data structure design | LeetCode OJ

解法1：DFS配合字典树，效率其实并不高。有意思的事我居然一次AC了。

// Solution 1: DFS on a trie, works but not very efficient. Still, one shot one kill is good enough.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0211_add-and-search-word-data-structure-design_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0211_add-and-search-word-data-structure-design_1_AC.cpp)

<hr>

#212 Word Search II

// #212 找单词2

描述：和之前一样，不过这次要找出矩阵中所有的单词。

// [#212](https://leetcode.com/problems/word-search-ii/) Description: Word Search II | LeetCode OJ

解法1：还是DFS。

// Solution 1: DFS.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0212_word-search-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0212_word-search-ii_1_AC.cpp)

<hr>

#213 House Robber II

// #213 小偷2

描述：跟之前一样，不过这次房子围成一个圈，所以首尾也算是相邻的。问该怎么偷。

// [#213](https://leetcode.com/problems/house-robber-ii/) Description: House Robber II | LeetCode OJ

解法1：既然首尾相邻了，我们就把按照首尾，分两种情况考虑。

// Solution 1: Since 0 and n - 1 are now considered adjacent, we cover both situations separately.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0213_house-robber-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0213_house-robber-ii_1_AC.cpp)

<hr>

#214 Shortest Palindrome

// #214 最短回文串

描述：给定字符串，允许你在开头添加字母，将其变为一个回文串。问最少需要添加几个字母。

// [#214](https://leetcode.com/problems/shortest-palindrome/) Description: Shortest Palindrome | LeetCode OJ

解法1：用哈希可以将字符串匹配的时间复杂度降低一个维度， 前提是你忽略碰撞的可能性。所以这个方法可以写出O(N)的算法。此外还要记住一点：KMP算法中的next数组是非常有用的，不论是最长回文前缀、最长回文后缀、最短循环节等等问题，都可以用类似的思路搞定。因为，这些问题是可以相互转换，举一反三、融会贯通者，此之谓也。这题也一样可以用类似方法搞定。

// Solution 1: String hashing can reduce the time complexity of matching by one dimension, thus you can write an O(N) solution if you're willing to ignore the possibility of hashing collision. Also, keep in mind that the "next" array in KMP Algorithm is very powerful. Whether it's longest palindromic prefix, suffix or shortest repetend that you want, it'll help you get the job done. That's what I call "you see one, you see them all". The same works for this one, too.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0214_shortest-palindrome_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0214_shortest-palindrome_1_AC.cpp)

<hr>

#215 Kth Largest Element in an Array

// #215 数组中第k大的元素

描述：如题。

// [#215](https://leetcode.com/problems/kth-largest-element-in-an-array/) Description: Kth Largest Element in an Array | LeetCode OJ

解法1：你能手写快速排序吧？面试经常考哦。稍加修改就变成快速选择算法了。用此算法可以找出第k小元素。

// Solution 1: Can you write by Quick Sort hand? They say it's a popular problem. It can be easily modified to Quick Select algorithm which can be used to find the k-th smallest element.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0215_kth-largest-element-in-an-array_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0215_kth-largest-element-in-an-array_1_AC.cpp)

<hr>

#216 Combination Sum III

// #216 组合之和3

描述：用k个1~9加成一个数n，求所有组合方式。

// [#216](https://leetcode.com/problems/combination-sum-iii/) Description: Combination Sum III | LeetCode OJ

解法1：DFS。

// Solution 1: DFS.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0216_combination-sum-iii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0216_combination-sum-iii_1_AC.cpp)

<hr>

#217 Contains Duplicate

// #217 数组查重

描述：如题。

// [#217](https://leetcode.com/problems/contains-duplicate/) Description: Contains Duplicate | LeetCode OJ

解法1：哈希。

// Solution 1: Hash.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0217_contains-duplicate_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0217_contains-duplicate_1_AC.cpp)

<hr>

#218 The Skyline Problem

// #218 轮郭线问题

描述：给定一些矩形建筑物的横纵坐标，求出总体轮廓线的形状。

// [#218](https://leetcode.com/problems/the-skyline-problem/) Description: The Skyline Problem | LeetCode OJ

解法1：这题解法可以很多，但关键都是一点：随时获取当前最高建筑物的高度。用map或者priority_queue都行，只要保证有序。

// Solution 1: This problem can be handled in various ways, all focus but on one point: knowing the height of the current highest building. Using either map or priority_queue is OK, as both are sorted data structures.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0218_the-skyline-problem_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0218_the-skyline-problem_1_AC.cpp)

<hr>

#219 Contains Duplicate II

// #219 数组查重2

描述：和之前一样，不过这次要求两重复元素必须距离不超过k。

// [#219](https://leetcode.com/problems/contains-duplicate-ii/) Description: Contains Duplicate II | LeetCode OJ

解法1：不就是滑动窗口嘛。

// Solution 1: So it's sliding window this time.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0219_contains-duplicate-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0219_contains-duplicate-ii_1_AC.cpp)

<hr>

#220 Contains Duplicate III

// #220 数组查重3

描述：和之前一样，不过这次俩元素之间的差不超过t，下标距离不超过k。

// [#220](https://leetcode.com/problems/contains-duplicate-iii/) Description: Contains Duplicate III | LeetCode OJ

解法1：一样的把戏。

// Solution 1: Same trick.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0220_contains-duplicate-iii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0220_contains-duplicate-iii_1_AC.cpp)

<hr>

#221 Maximal Square

// #221 最大方形

描述：和之前一样，不过这题要求的方形，不是矩形。

// [#221](https://leetcode.com/problems/maximal-square/) Description: Maximal Square | LeetCode OJ

解法1：和Maximal Rectangle一样。

// Solution 1: Same as Maximal Rectangle.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0221_maximal-square_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0221_maximal-square_1_AC.cpp)

<hr>

#222 Count Complete Tree Nodes

// #222 统计完全二叉树节点个数

描述：如题。

// [#222](https://leetcode.com/problems/count-complete-tree-nodes/) Description: Count Complete Tree Nodes | LeetCode OJ

解法1：可以二分。

// Solution 1: Binary search.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0222_count-complete-tree-nodes_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0222_count-complete-tree-nodes_1_AC.cpp)

<hr>

#223 Rectangle Area

// #223 矩形面积

描述：给定两个横平竖直的矩形，求总覆盖面积。

// [#223](https://leetcode.com/problems/rectangle-area/) Description: Rectangle Area | LeetCode OJ

解法1：求交。

// Solution 1: Find the intersection.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0223_rectangle-area_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0223_rectangle-area_1_AC.cpp)

<hr>

#224 Basic Calculator

// #224 简易计算器

描述：实现支持加减括号的计算器。

// [#224](https://leetcode.com/problems/basic-calculator/) Description: Basic Calculator | LeetCode OJ

解法1：这题是个考验可扩展性的好例子。怎么处理加减乘除括号其实并不重要，规则说出来人人都懂。但要你额外支持%^&|等等运算，你的代码能用几行修改搞定吗？这才是关键。

// Solution 1: This problem is a good test for code scalability. How we deal with arithmetics and parentheses is not the real challenge, it's the ability to make your code adaptive to new operators like %^&| etc. at the cost of only a few lines of new code that really matters.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0224_basic-calculator_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0224_basic-calculator_1_AC.cpp)

<hr>

#225 Implement Stack using Queues

// #225 用栈实现队列

描述：如题。

// [#225](https://leetcode.com/problems/implement-stack-using-queues/) Description: Implement Stack using Queues | LeetCode OJ

解法1：负负得正，很好。正正得负？很清真。这题就是吃饱了撑的。

// Solution 1: -1 x -1 = 1, correct. 1 x 1 = -1? Talos guide you. I don't see no reason to see such nonsense here no more.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0225_implement-stack-using-queues_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0225_implement-stack-using-queues_1_AC.cpp)

<hr>

#226 Invert Binary Tree

// #226 反转二叉树

描述：如题。

// [#226](https://leetcode.com/problems/invert-binary-tree/) Description: Invert Binary Tree | LeetCode OJ

解法1：不会这题，好像确实很难。

// Solution 1:

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0226_invert-binary-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0226_invert-binary-tree_1_AC.cpp)

<hr>

#227 Basic Calculator II

// #227 简易计算器2

描述：和之前差不多，这次支持加减乘除，不用支持括号。

// [#227](https://leetcode.com/problems/basic-calculator-ii/) Description: Basic Calculator II | LeetCode OJ

解法1：之前已经全部实现了，所以不用修改代码。

// Solution 1: Already taken care of.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0227_basic-calculator-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0227_basic-calculator-ii_1_AC.cpp)

<hr>

#228 Summary Ranges

// #228 区间统计

描述：给定一个数组，统计其中元素的区间分布。

// [#228](https://leetcode.com/problems/summary-ranges/) Description: Summary Ranges | LeetCode OJ

解法1：哈希表。

// Solution 1: Hash table.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0228_summary-ranges_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0228_summary-ranges_1_AC.cpp)

<hr>

#229 Majority Element II

// #229 众数2

描述：和之前一样，不过这次是超过1/3的元素。

// [#229](https://leetcode.com/problems/majority-element-ii/) Description: Majority Element II | LeetCode OJ

解法1：超过1/k的元素，至多有k - 1个，至少有0个。其实还是Boyer-Moore投票算法，只不过是推广后的。

// Solution 1: There can be at most k - 1 k-majority elements, at least 0. It's still a Boyer-Moore Voting Problem, just in a more generalized sense.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0229_majority-element-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0229_majority-element-ii_1_AC.cpp)

<hr>

#230 Kth Smallest Element in a BST

// #230 二叉搜索树第k小节点

描述：如题。

// [#230](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) Description: Kth Smallest Element in a BST | LeetCode OJ

解法1：统计以每个节点为根的子树有多少节点，这样就能清楚每走一步跳过了多少节点。对于数据结构经常更新，这种问题。不要老想着如何把数据结构和一堆计数器绑在一起，而要想着用时间戳等工具来判断是否有必要重新计算结果。缓存缓存，目的是用来缓一缓，而不是一劳永逸。

// Solution 1: Keep the statistics of number of nodes for every node in the tree. If you need statistics of a data structure which changes quite often, don't try to bind them together too tight. Use things like timestamps to check if the results in cache needs updating. It's a cache, not history book or tombstone.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0230_kth-smallest-element-in-a-bst_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0230_kth-smallest-element-in-a-bst_1_AC.cpp)

<hr>

#231 Power of Two

// #231 2的幂

描述：给定一个整数，判断是不是2的整次幂。

// [#231](https://leetcode.com/problems/power-of-two/) Description: Power of Two | LeetCode OJ

解法1：注意边界条件。

// Solution 1: Edge cases.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0231_power-of-two_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0231_power-of-two_1_AC.cpp)

<hr>

#232 Implement Queue using Stacks

// #232 用栈实现队列

描述：如题。

// [#232](https://leetcode.com/problems/implement-queue-using-stacks/) Description: Implement Queue using Stacks | LeetCode OJ

解法1：负负得正。

// Solution 1: -1 x -1 = 1

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0232_implement-queue-using-stacks_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0232_implement-queue-using-stacks_1_AC.cpp)

<hr>

#233 Number of Digit One

// #233 1的个数

描述：统计1~n中数字1出现次数。

// [#233](https://leetcode.com/problems/number-of-digit-one/) Description: Number of Digit One | LeetCode OJ

解法1：我讨厌数数。

// Solution 1: I hate counting.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0233_number-of-digit-one_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0233_number-of-digit-one_1_AC.cpp)

<hr>

#234 Palindrome Linked List

// #234 回文链表

描述：给定链表，判断是否对称。

// [#234](https://leetcode.com/problems/palindrome-linked-list/) Description: Palindrome Linked List | LeetCode OJ

解法1：对半分，反转一个，判断是否相同。

// Solution 1: Split in half, reverse one, check for a match.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0234_palindrome-linked-list_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0234_palindrome-linked-list_1_AC.cpp)

<hr>

#235 Lowest Common Ancestor of a Binary Search Tree

// #235 二叉搜索树最近公共祖先

描述：如题。

// [#235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) Description: Lowest Common Ancestor of a Binary Search Tree | LeetCode OJ

解法1：二分。

// Solution 1: Binary search.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0235_lowest-common-ancestor-of-a-binary-search-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0235_lowest-common-ancestor-of-a-binary-search-tree_1_AC.cpp)

<hr>

#236 Lowest Common Ancestor of a Binary Tree

// #236 二叉树最近公共祖先

描述：如题。

// [#236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) Description: Lowest Common Ancestor of a Binary Tree | LeetCode OJ

解法1：Naive。

// Solution 1: Naive.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0236_lowest-common-ancestor-of-a-binary-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0236_lowest-common-ancestor-of-a-binary-tree_1_AC.cpp)

<hr>

#237 Delete Node in a Linked List

// #237 删除链表节点

描述：给定一个链表节点，把这节点删掉。

// [#237](https://leetcode.com/problems/delete-node-in-a-linked-list/) Description: Delete Node in a Linked List | LeetCode OJ

解法1：老题。

// Solution 1: Old.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0237_delete-node-in-a-linked-list_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0237_delete-node-in-a-linked-list_1_AC.cpp)

<hr>

#238 Product of Array Except Self

// #238 除了自身以外的数组元素乘积

描述：给定一个数组，计算出每个元素对应的除自己以外其他元素的乘积。

// [#238](https://leetcode.com/problems/product-of-array-except-self/) Description: Product of Array Except Self | LeetCode OJ

解法1：从左往右，从右往左。

// Solution 1: Left to right, right to left.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0238_product-of-array-except-self_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0238_product-of-array-except-self_1_AC.cpp)

<hr>

#239 Sliding Window Maximum

// #239 滑动窗口最大值

描述：给定一个长度为k的滑动窗口不断从左往右滑动，给出过程中的各个最大值。

// [#239](https://leetcode.com/problems/sliding-window-maximum/) Description: Sliding Window Maximum | LeetCode OJ

解法1：滑动窗口嘛，哈希搞一个。

// Solution 1: Sliding window again, let's hash.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0239_sliding-window-maximum_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0239_sliding-window-maximum_1_AC.cpp)

<hr>

#240 Search a 2D Matrix II

// #240 二维数组查找

描述：给定一个杨氏矩阵，查找一个值。

// [#240](https://leetcode.com/problems/search-a-2d-matrix-ii/) Description: Search a 2D Matrix II | LeetCode OJ

解法1：俩指针，但这次在两条坐标轴上。

// Solution 1: Two pointers as well but on different axes this time.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0240_search-a-2d-matrix-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0240_search-a-2d-matrix-ii_1_AC.cpp)

<hr>

#241 Different Ways to Add Parentheses

// #241 添加括号的不同方法

描述：给定一个包含加减乘的算数表达式，允许你任意加括号，求可能有多少种不同结果。

// [#241](https://leetcode.com/problems/different-ways-to-add-parentheses/) Description: Different Ways to Add Parentheses | LeetCode OJ

解法1：可以DFS，也可以DP。

// Solution 1: DFS or DP, either way you gotta work it out.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0241_different-ways-to-add-parentheses_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0241_different-ways-to-add-parentheses_1_AC.cpp)

<hr>

#242 Valid Anagram

// #242 合法的变位词

描述：检查两词是否字母构成相同。

// [#242](https://leetcode.com/problems/valid-anagram/) Description: Valid Anagram | LeetCode OJ

解法1：数数。

// Solution 1: Count it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0242_valid-anagram_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0242_valid-anagram_1_AC.cpp)

解法2：排序。

// Solution 2: Sort it.

[代码2](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0242_valid-anagram_2_AC.cpp)

// [Code 2](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0242_valid-anagram_2_AC.cpp)

解法3：哈希。

// Solution 3: Hash it.

[代码3](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0242_valid-anagram_3_AC.cpp)

// [Code 3](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0242_valid-anagram_3_AC.cpp)

<hr>

#243 Shortest Word Distance

// #243 最短单词距离

描述：给定一列单词和俩单词，求这俩单词在一列中的最近距离。

// [#243](https://leetcode.com/problems/shortest-word-distance/) Description: Shortest Word Distance | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0243_shortest-word-distance_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0243_shortest-word-distance_1_AC.cpp)

<hr>

#244 Shortest Word Distance II

// #244 最短单词距离2

描述：和之前一样，不过这次对于同一单词表，可能查询多次最短距离。

// [#244](https://leetcode.com/problems/shortest-word-distance-ii/) Description: Shortest Word Distance II | LeetCode OJ

解法1：基本思路和之前一样，不过这次用哈希表统计下各个单词出现的所有下标，方便后面查找。同时把查询结果缓存下来，避免重复计算。

// Solution 1: The basic idea is the same, but this time we use a hash table to record all the indices of all distinct words, thus accelerating the search. The search results are cached to avoid redundant computation.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0244_shortest-word-distance-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0244_shortest-word-distance-ii_1_AC.cpp)

<hr>

#245 Shortest Word Distance III

// #245 单词最短距离3

描述：和之前一样，不过这次俩单词可以相同。

// [#245](https://leetcode.com/problems/shortest-word-distance-iii/) Description: Shortest Word Distance III | LeetCode OJ

解法1：一样。

// Solution 1: The same.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0245_shortest-word-distance-iii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0245_shortest-word-distance-iii_1_AC.cpp)

<hr>

#246 Strobogrammatic Number

// #246 翻转数

描述：一个数如果翻转180度后还是不变，称为“翻转数”。判断给定数是否为翻转数。

// [#246](https://leetcode.com/problems/strobogrammatic-number/) Description: Strobogrammatic Number | LeetCode OJ

解法1：无聊。

// Solution 1: Boring.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0246_strobogrammatic-number_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0246_strobogrammatic-number_1_AC.cpp)

<hr>

#247 Strobogrammatic Number II

// #247 翻转数2

描述：给定一个长度n，找出所有长度为n的翻转数。

// [#247](https://leetcode.com/problems/strobogrammatic-number-ii/) Description: Strobogrammatic Number II | LeetCode OJ

解法1：考虑每一位数字可以填哪些数就行了，这是个乘法问题。

// Solution 1: Think about the digits you can fill on each position. It's a matter of multiplication.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0247_strobogrammatic-number-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0247_strobogrammatic-number-ii_1_AC.cpp)

<hr>

#248 Strobogrammatic Number III

// #248 翻转数3

描述：给定一个区间，求此区间内所有翻转数的个数。

// [#248](https://leetcode.com/problems/strobogrammatic-number-iii/) Description: Strobogrammatic Number III | LeetCode OJ

解法1：这题非常有挑战性，也可能是因为看起来就比较难吧。我确实想了很久，而且写乐好久才写出能AC的代码。大体的思路当然是从1~n数数着手，不过处理边界情况倒是比想象中更棘手。还是看代码吧，我都很难讲清楚自己当时的思路。

// Solution 1: This is a very challenging problem, maybe because it looked like one and proved exactly to be one. It's among the last few problem I solved on LeetCode. It took me hours to think it through and another 1 or 2 to write an acceptable version of code. A rough idea would be a 1~n counting. This counting is no easier than I thought. Better read the code, because I can't even explain my solution clearly.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0248_strobogrammatic-number-iii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0248_strobogrammatic-number-iii_1_AC.cpp)

<hr>

#249 Group Shifted Strings

// #249 归类移位字符串

描述：给定一堆字符串，将移位字符串归类到一起。此处“移位字符串”的定义是将串中所有字符按照a~z的范围循环移位某个固定值，如果两个字符串可以通过移位变成同一串，则互为“移位字符串”。

// [#249](https://leetcode.com/problems/group-shifted-strings/) Description: Group Shifted Strings | LeetCode OJ

解法1：既然可以任意移位，我们就通过移位把首字符都变成某个固定字母比如a或z，这样就可以将移位字符串聚类了。

// Solution 1: Since we're free to make the shift by any offset, it's OK to shift th string so that all the initials of the strings are shifted to a certain character like 'a' or 'z'. In this way, all shifted strings become one. Group them in this way.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0249_group-shifted-strings_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0249_group-shifted-strings_1_AC.cpp)

<hr>

#250 Count Univalue Subtrees

// #250 统计单值子树

描述：给定一棵二叉树，统计单值二叉树的个数。单值二叉树的定义是一棵非空，并且所有节点都同值的二叉树。

// [#250](https://leetcode.com/problems/count-univalue-subtrees/) Description: Count Univalue Subtrees | LeetCode OJ

解法1：遍历。

// Solution 1: Traverse it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0250_count-univalue-subtrees_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0250_count-univalue-subtrees_1_AC.cpp)

<hr>

#251 Flatten 2D Vector

// #251 展开二维数组

描述：为一个长度可能不一的二维数组写一个迭代器，以便像一维数组一样是逐个访问其中元素。

// [#251](https://leetcode.com/problems/flatten-2d-vector/) Description: Flatten 2D Vector | LeetCode OJ

解法1：和算法无关，注意细节就好。

// Solution 1: If it's not about algorithms, it's about discreetness.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0251_flatten-2d-vector_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0251_flatten-2d-vector_1_AC.cpp)

<hr>

#252 Meeting Rooms

// #252 会议室

描述：给定一些区间，判断是否有重合。

// [#252](https://leetcode.com/problems/meeting-rooms/) Description: Meeting Rooms | LeetCode OJ

解法1：排个序，扫一遍。

// Solution 1: Sort and scan.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0252_meeting-rooms_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0252_meeting-rooms_1_AC.cpp)

<hr>

#253 Meeting Rooms II

// #253 会议室2

描述：给定一系列会议起始时间，判断需要多少个会议室才够用。

// [#253](https://leetcode.com/problems/meeting-rooms-ii/) Description: Meeting Rooms II | LeetCode OJ

解法1：看代码，不解释。

// Solution 1: Let the code explain itself.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0253_meeting-rooms-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0253_meeting-rooms-ii_1_AC.cpp)

<hr>

#254 Factor Combinations

// #254 因式组合

描述：给定正整数n，返回所有乘积等于n的不同组合，除了n = n。为避免重复，所有乘数单调递增。

// [#254](https://leetcode.com/problems/factor-combinations/) Description: Factor Combinations | LeetCode OJ

解法1：DFS。

// Solution 1: DFS.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0254_factor-combinations_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0254_factor-combinations_1_AC.cpp)

<hr>

#255 Verify Preorder Sequence in Binary Search Tree

// #255 验证二叉搜索树前序遍历

描述：给定一个数组，判断其是否可能是有效地二叉搜索树前序遍历。

// [#255](https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/) Description: Verify Preorder Sequence in Binary Search Tree | LeetCode OJ

解法1：我们遍历树时要用栈，验证的时候也可以这么做。为什么？因为你要检验正确性，一种可行的方法就是照做一遍。

// Solution 1: We use a stack when traversing a tree, we do the same when checking it. Why this? You wanna verify something, you gotta repeat the process yourself and see if it works.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0255_verify-preorder-sequence-in-binary-search-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0255_verify-preorder-sequence-in-binary-search-tree_1_AC.cpp)

<hr>

#256 Paint House

// #256 刷房子

描述：有一排房子共n间，现在允许用红绿蓝三色刷房子，要求相邻房子不能同色。房子和颜色有一个对应的代价矩阵，求最小代价。

// [#256](https://leetcode.com/problems/paint-house/) Description: Paint House | LeetCode OJ

解法1：DP。

// Solution 1: DP.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0256_paint-house_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0256_paint-house_1_AC.cpp)

<hr>

#257 Binary Tree Paths

// #257 二叉树路径

描述：给定一棵二叉树，求出所有根到叶的路径。

// [#257](https://leetcode.com/problems/binary-tree-paths/) Description: Binary Tree Paths | LeetCode OJ

解法1：遍历。

// Solution 1: Traverse it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0257_binary-tree-paths_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0257_binary-tree-paths_1_AC.cpp)

<hr>

#258 Add Digits

// #258 数位相机

描述：Digital root听过吗？

// [#258](https://leetcode.com/problems/add-digits/) Description: Add Digits | LeetCode OJ

解法1：膜9同余。

// Solution 1: The digital root is congruent with the original number modulo 9.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0258_add-digits_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0258_add-digits_1_AC.cpp)

<hr>

#259 3Sum Smaller

// #259 较小的三数之和

描述：给定一个数组和一个值target，求出三数之和小于target的所有组合个数。

// [#259](https://leetcode.com/problems/3sum-smaller/) Description: 3Sum Smaller | LeetCode OJ

解法1：排个序，三指针。

// Solution 1: Sort the array and run three pointers on it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0259_3sum-smaller_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0259_3sum-smaller_1_AC.cpp)

<hr>

#260 Single Number III

// #260 孤独数2

描述：给定一个数组，除了俩数出现一次以外，其他数都出现了两次。求这俩数。

// [#260](https://leetcode.com/problems/single-number-iii/) Description: Single Number III | LeetCode OJ

解法1：所有元素异或，可以得到一个非0的值。从此值中随便取一个1位，即可作为筛选的依据。所有元素会被分为两部分。两部分各自做异或操作，最后得到的就是结果。

// Solution 1: XOR every element to get a result S. Extract a '1' bit from S and use this bit as a filter to split the array into two parts. The XOR results of both parts are what we are looking for.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0260_single-number-iii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0260_single-number-iii_1_AC.cpp)

<hr>

#261 Graph Valid Tree

// #261 有效树形图

描述：给定一个无向图，判断其是否是一个有效地树形结构。

// [#261](https://leetcode.com/problems/graph-valid-tree/) Description: Graph Valid Tree | LeetCode OJ

解法1：N节点的树，必有N - 1条边，而且无环。那么，N = 0呢？

// Solution 1: What makes an undirected graph a tree? What about an empty graph?

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0261_graph-valid-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0261_graph-valid-tree_1_AC.cpp)

<hr>

#263 Ugly Number

// #263 丑数

描述：给定一个整数，判断其是否为丑数。丑数的定义为1或者大于1且质因数只包含2、3、5的数。

// [#263](https://leetcode.com/problems/ugly-number/) Description: Ugly Number | LeetCode OJ

解法1：用2、3、5去除就行了。

// Solution 1: Just divide it by 2, 3 and 5.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0263_ugly-number_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0263_ugly-number_1_AC.cpp)

<hr>

#264 Ugly Number II

// #264 丑数2

描述：根据丑数的定义，求第n个丑数。

// [#264](https://leetcode.com/problems/ugly-number-ii/) Description: Ugly Number II | LeetCode OJ

解法1：为每个质因数维护一个指针，每次比较三个乘积，取最小值。如此三个指针各自不断前进，可以递推下去。

// Solution 1: Maintain a pointer for every prime factor. Pick the smallest product each time and update the corresponding pointers, thus they'll keep pushing forward.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0264_ugly-number-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0264_ugly-number-ii_1_AC.cpp)

<hr>

#265 Paint House II

// #265 刷房子2

描述：和之前一样，不过这次有k种颜色，而不是3种，求最小代价。

// [#265](https://leetcode.com/problems/paint-house-ii/) Description: Paint House II | LeetCode OJ

解法1：显然还是DP，不过这次我们可以想想如何围绕k进行优化。想想Product of Array Except Self吧。

// Solution 1: Apparently it's still about DP, but this time we gotta focus on the optimization around k. Think about Product of Array Except Self.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0265_paint-house-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0265_paint-house-ii_1_AC.cpp)

<hr>

#266 Palindrome Permutation

// #266 回文排列

描述：给定一个字符串，判断是否能通过适当排序将其变为回文串。

// [#266](https://leetcode.com/problems/palindrome-permutation/) Description: Palindrome Permutation | LeetCode OJ

解法1：数数。

// Solution 1: Count it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0266_palindrome-permutation_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0266_palindrome-permutation_1_AC.cpp)

<hr>

#267 Palindrome Permutation II

// #267 回文排列2

描述：给定一个字符串，返回其能重排成的所有回文串。

// [#267](https://leetcode.com/problems/palindrome-permutation-ii/) Description: Palindrome Permutation II | LeetCode OJ

解法1：跟全排列是一个道理，你说对吗？

// Solution 1: It's actually the same as covering different permuations of a string, right?

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0267_palindrome-permutation-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0267_palindrome-permutation-ii_1_AC.cpp)

<hr>

#268 Missing Number

// #268 缺少的数

描述：给定n个从0~n选出的不重复的数，找出缺的那个数。

// [#268](https://leetcode.com/problems/missing-number/) Description: Missing Number | LeetCode OJ

解法1：因为数据范围的限制，原数组就可以作为一个标记数组来使用。

// Solution 1: Due to the limit of data range, the input array can serve as a marker array.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0268_missing-number_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0268_missing-number_1_AC.cpp)

<hr>

#269 Alien Dictionary

// #269 外星字典

描述：给定一组单词，已知这些单词的排列顺序是符合某种奇怪的字典序的。请求出这种字典序下各个字母的排列顺序，对于存在多种答案者，给出任一即可。

// [#269](https://leetcode.com/problems/alien-dictionary/) Description: Alien Dictionary | LeetCode OJ

解法1：拓扑排序。

// Solution 1: Topological sort.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0269_alien-dictionary_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0269_alien-dictionary_1_AC.cpp)

<hr>

#270 Closest Binary Search Tree Value

// #270 二叉搜索树中最近的值

描述：给定一棵二叉搜索树和一个值，求出其节点中最接近的值。

// [#270](https://leetcode.com/problems/closest-binary-search-tree-value/) Description: Closest Binary Search Tree Value | LeetCode OJ

解法1：中序遍历。其实这题是可以二分搜索。

// Solution 1: Inorder traversal. This problem can actually be solved by binary search.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0270_closest-binary-search-tree-value_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0270_closest-binary-search-tree-value_1_AC.cpp)

<hr>

#271 Encode and Decode Strings

// #271 编码解码字符串

描述：给定一个字符串，编写编码解码算法。字典包括所有256个ASCII字符。

// [#271](https://leetcode.com/problems/encode-and-decode-strings/) Description: Encode and Decode Strings | LeetCode OJ

解法1：方法随便你怎么写，要考虑到网络传输中实际能接受的字典集合，考虑编解码的压缩比率等等。我就写个Base64好了。

// Solution 1: Whatever scheme you choose for the encoding and decoding, take the dict set, ratio of compression etc. into account. Here I take Base64 for an instance.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0271_encode-and-decode-strings_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0271_encode-and-decode-strings_1_AC.cpp)

<hr>

#272 Closest Binary Search Tree Value II

// #272 二叉搜索树中最近的值2

描述： 和之前一样，不过这次要找的是最接近的k个值。

// [#272](https://leetcode.com/problems/closest-binary-search-tree-value-ii/) Description: Closest Binary Search Tree Value II | LeetCode OJ

解法1：最接近的k个值，一定分布在target的左和右。于是我们用二分搜索找到分界线，然后往两边遍历即可。说到遍历你想到什么了？没错，迭代器。所以我手写了两个迭代器，一个正向，一个反向。你看，这不就是OOP么？这题很有挑战性。

// Solution 1: Since we need the k closest values, a feasible way is to find the closet value to target by binary search and start traversing from this point in both directions. Thus we'll need a forward iterator and a reverse iterator. Here is an OOP solution. Try writing your own iterators, it's basic training. A challenging problem.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0272_closest-binary-search-tree-value-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0272_closest-binary-search-tree-value-ii_1_AC.cpp)

<hr>

#273 Integer to English Words

// #273 整数转英文单词

描述：给定一个整数，用英文读出来。

// [#273](https://leetcode.com/problems/integer-to-english-words/) Description: Integer to English Words | LeetCode OJ

解法1：不难，但是很麻烦。

// Solution 1: Ain't no big problem, but some hard labor indeed.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0273_integer-to-english-words_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0273_integer-to-english-words_1_AC.cpp)

<hr>

#274 H-Index

// #274 H指数

描述：给定一个学者的论著列表，我们定义H指数：该学者的N篇论著里有H篇引用数不小于H，并且剩余的N - H篇引用数不大于H。满足此条件的最大H称为其H指数。求此人的H指数。

// [#274](https://leetcode.com/problems/h-index/) Description: H-Index | LeetCode OJ

解法1：排序，二分。

// Solution 1: Sort and binary search.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0274_h-index_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0274_h-index_1_AC.cpp)

<hr>

#275 H-Index II

// #275 H指数2

描述：如果数组有序，又当如何？

// [#275](https://leetcode.com/problems/h-index-ii/) Description: H-Index II | LeetCode OJ

解法1：如出一辙。

// Solution 1: What a coincidence.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0275_h-index-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0275_h-index-ii_1_AC.cpp)

<hr>

#276 Paint Fence

// #276 刷篱笆

描述：有n个篱笆栓子，每个刷一种颜色。你有k种颜色可选，要求至多相邻俩栓子同色。问共有多少种不同刷法？

// [#276](https://leetcode.com/problems/paint-fence/) Description: Paint Fence | LeetCode OJ

解法1：厘清递推关系。

// Solution 1: Understand the recurrence relation.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0276_paint-fence_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0276_paint-fence_1_AC.cpp)

<hr>

#277 Find the Celebrity

// #277 找大腕儿

描述：有这么一帮子人，只允许你问“谁认识谁”，想个法儿把腕儿给找出来。什么叫腕儿？谁都认识TA老人家，TA老人家谁也不认。

// [#277](https://leetcode.com/problems/find-the-celebrity/) Description: Find the Celebrity | LeetCode OJ

解法1：按定义判断，使用排除法。最坏时间复杂度O(N ^ 2)。

// Solution 1: Follow the process of elimination by the given definition of celebrities. Worst time can reach O(N ^ 2).

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0277_find-the-celebrity_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0277_find-the-celebrity_1_AC.cpp)

<hr>

#278 First Bad Version

// #278 第一个坏版本

描述：某版本出了问题，后面跟着都坏了。找找。

// [#278](https://leetcode.com/problems/first-bad-version/) Description: First Bad Version | LeetCode OJ

解法1：二分。

// Solution 1: Binary search.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0278_first-bad-version_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0278_first-bad-version_1_AC.cpp)

<hr>

#279 Perfect Squares

// #279 完全平方数

描述：给定一个整数，求至少几个完全平方数可以加成该数。

// [#279](https://leetcode.com/problems/perfect-squares/) Description: Perfect Squares | LeetCode OJ

解法1：此题的通解明显要用DP，不过对于N很小的时候，貌似有数学解，需要组合数学知识。

// Solution 1: The general solution of this problem requires DP, but for small N there seems to be some mathematical solutions available, if you know combinatorial maths.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0279_perfect-squares_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0279_perfect-squares_1_AC.cpp)

<hr>

#280 Wiggle Sort

// #280 摆动排序

描述：给定一个无序数组，用O(1)的空间代价将数组排成“小大小大小...”的形式。

// [#280](https://leetcode.com/problems/wiggle-sort/) Description: Wiggle Sort | LeetCode OJ

解法1：中位数是关键。这题代码真心不好写。

// Solution 1: Median is the key. It's not easy, I mean it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0280_wiggle-sort_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0280_wiggle-sort_1_AC.cpp)

<hr>

#281 Zigzag Iterator

// #281 Z形迭代器

描述：给定两个数组，按照“上下上下...”的方式逐个遍历，要求写成迭代器的形式。

// [#281](https://leetcode.com/problems/zigzag-iterator/) Description: Zigzag Iterator | LeetCode OJ

解法1：没什么意思，写呗。

// Solution 1: Boring.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0281_zigzag-iterator_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0281_zigzag-iterator_1_AC.cpp)

<hr>

#282 Expression Add Operators

// #282 表达式添加运算符

描述：给定一个数字串S和一个值target，允许你在S中间添加加减乘符号，使得表达式结果为target，求所有添法。

// [#282](https://leetcode.com/problems/expression-add-operators/) Description: Expression Add Operators | LeetCode OJ

解法1：暴力DFS，适当剪枝。

// Solution 1: Brute-force DFS with a little pruning.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0282_expression-add-operators_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0282_expression-add-operators_1_AC.cpp)

<hr>

#283 Move Zeroes

// #283 移0

描述：把数组中的0移到末尾去。

// [#283](https://leetcode.com/problems/move-zeroes/) Description: Move Zeroes | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0283_move-zeroes_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0283_move-zeroes_1_AC.cpp)

<hr>

#284 Peeking Iterator

// #284 预读迭代器

描述：在已给定的迭代器基础上，实现预读功能。

// [#284](https://leetcode.com/problems/peeking-iterator/) Description: Peeking Iterator | LeetCode OJ

解法1：好像没什么值得说的。

// Solution 1: Nothing worth mentioning.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0284_peeking-iterator_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0284_peeking-iterator_1_AC.cpp)

<hr>

#285 Inorder Successor in BST

// #285 二叉搜索树的中序后继节点

描述：如题。

// [#285](https://leetcode.com/problems/inorder-successor-in-bst/) Description: Inorder Successor in BST | LeetCode OJ

解法1：右转左下，左上右转。

// Solution 1: Turn right and go down left, or go up left and turn right.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0285_inorder-successor-in-bst_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0285_inorder-successor-in-bst_1_AC.cpp)

<hr>

#286 Walls and Gates

// #286 墙和门

描述：给定一个矩阵，有门，有空房，有障碍物。求出每个空房到离它最近的门的距离。如果到不了，就用INF表示。

// [#286](https://leetcode.com/problems/walls-and-gates/) Description: Walls and Gates | LeetCode OJ

解法1：思路当然是BFS，不过你不妨想象，从空房到门，和从门到空房，两种搜索有什么区别？区别就在于谁多谁少。以少搜多，效率更高。

// Solution 1: It's obviously a searching problem. You might as well think about the difference between searching from empty cells to gates, and the ways backwards. The key lies in whether there're more empty cells or more gates.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0286_walls-and-gates_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0286_walls-and-gates_1_AC.cpp)

<hr>

#287 Find the Duplicate Number

// #287 数组查重

描述：给定长度为n + 1的数组，其中元素都是1~n。求出重复元素。

// [#287](https://leetcode.com/problems/find-the-duplicate-number/) Description: Find the Duplicate Number | LeetCode OJ

解法1：这数组可以看成一个单链表，这链表肯定有环。

// Solution 1: This array is equivalent to a linked list, which is bound to have at least one loop.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0287_find-the-duplicate-number_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0287_find-the-duplicate-number_1_AC.cpp)

解法2：思路类似，但这次连数组都不用修改。

// Solution 2: Similar thoughts, this time we don't even modify the array.

[代码2](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0287_find-the-duplicate-number_2_AC.cpp)

// [Code 2](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0287_find-the-duplicate-number_2_AC.cpp)

<hr>

#288 Unique Word Abbreviation

// #288 不同单词缩写

描述：可以把一个单词保留首尾字母，中间用长度代替，比如apple变成a3e。现在给定一个词典，对于一个词，判断词典里是否有和它缩写一样的。

// [#288](https://leetcode.com/problems/unique-word-abbreviation/) Description: Unique Word Abbreviation | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0288_unique-word-abbreviation_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0288_unique-word-abbreviation_1_AC.cpp)

<hr>

#289 Game of Life

// #289 生命游戏

描述：康威生命游戏 - 维基百科，自由的百科全书

// [#289](https://leetcode.com/problems/game-of-life/) Description: Game of Life | LeetCode OJ

解法1：既然规则这么复杂，咱们就照规矩办。对于既然是01矩阵，数据类型又是int型，完全装得下，就不必额外开矩阵了。

// Solution 1: The rule is well defined, so let's do things as told. It's a 01 matrix, with every element of int type, it's more than enough to hold an extra bit, saving the trouble of allocating another matrix.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0289_game-of-life_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0289_game-of-life_1_AC.cpp)

<hr>

#290 Word Pattern

// #290 单词模式

描述：给定一个字符串，和一句话。判断字符串的每个字母和这句话中的单词能否构成一一对应。

// [#290](https://leetcode.com/problems/word-pattern/) Description: Word Pattern | LeetCode OJ

解法1：双射嘛，俩哈希表搞定。

// Solution 1: Two hash tables for one bijection.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0290_word-pattern_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0290_word-pattern_1_AC.cpp)

<hr>

#291 Word Pattern II

// #291 单词模式2

描述：和之前一样，不过这次这句话的单词之间没有空格了。傻了吧？

// [#291](https://leetcode.com/problems/word-pattern-ii/) Description: Word Pattern II | LeetCode OJ

解法1：有空格分割，就是一道水题。这冷不丁儿没了空格，本来一目了然的东西，咱就得摸着黑找喽。当然，一一对应还得靠哈希表。

// Solution 1: With the spaces， it's piece of cake. Without it, we gotta make a search for what we want. Still, verifying the bijection requires hash tables.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0291_word-pattern-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0291_word-pattern-ii_1_AC.cpp)

<hr>

#292 Nim Game

// #292 拿石头游戏

描述：共N个石头，俩人轮流，每次只能拿走1~3个。谁恰好拿光了，谁就赢。问先手赢还是后手赢。

// [#292](https://leetcode.com/problems/nim-game/) Description: Nim Game | LeetCode OJ

解法1：谜之博弈论，从这题开始。

// Solution 1: You'll never understand Game Theory.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0292_nim-game_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0292_nim-game_1_AC.cpp)

<hr>

#293 Flip Game

// #293 翻转游戏

描述：有一个由+-组成的字符串，每次允许把++变成--。现在给定一个串，请返回一次操作以后的结果。

// [#293](https://leetcode.com/problems/flip-game/) Description: Flip Game | LeetCode OJ

解法1：翻呗。

// Solution 1: Do it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0293_flip-game_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0293_flip-game_1_AC.cpp)

<hr>

#294 Flip Game II

// #294 翻转游戏2

描述：按照上一题中给定的规则，俩人轮流进行翻转。现在给定一个初始字符串，问先手是不是稳赢？

// [#294](https://leetcode.com/problems/flip-game-ii/) Description: Flip Game II | LeetCode OJ

解法1：首先可以暴力搜，但这么干不优雅。如果稍微考虑一下，就能看到子问题在哪儿。每一个连续的+串就是子问题。所以呢？所以肯定有动态规划的解法。然而到这儿，我的思路就卡住了。一个声音告诉我：SG定理。夫天将降大任于码农，必先恶补数学。

// Solution 1: The first thought was to do a brute-force DFS. It'll do, but not very graceful. Later I found that every consecutive string of + can be considered a subproblem. Yes, that's the door to DP, but I couldn't find the key. As the prophecy comnends upon us: SG Theorem. You wanna be more than just a mere coding monkey? Learn some maths.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0294_flip-game-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0294_flip-game-ii_1_AC.cpp)

<hr>

#295 Find Median from Data Stream

// #295 数据流的中位数

描述：设计一个数据结构，能向其中添加元素，并能随时查询中位数。

// [#295](https://leetcode.com/problems/find-median-from-data-stream/) Description: Find Median from Data Stream | LeetCode OJ

解法1：既然是中位数，就是放在中间的数。所以，我们每次添加数的时候，都要保证数按照大小分成两堆，两堆要尽量一样多。不得不说，平衡树是个好东西。

// Solution 1: It's the median we want, it must lie in the middle. So every time we add something, make sure we put things in two half, one pile large, one pile small. Both sizes be as close as possible. Gotta admit, balanced BST comes in really handy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0295_find-median-from-data-stream_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0295_find-median-from-data-stream_1_AC.cpp)

<hr>

#296 Best Meeting Point

// #296 最佳见面地点

描述：给定一个01矩阵，1表示建筑，0表示空地。现在要求选择一处空地作为集合地点，要求离所有建筑之和最小。求最小距离之和。距离计算以曼哈顿距离为准。

// [#296](https://leetcode.com/problems/best-meeting-point/) Description: Best Meeting Point | LeetCode OJ

解法1：既然用的是曼哈顿距离，横向和纵向的距离就完全独立了。于是我们分别计算横向和纵向各个点的距离之和。这俩距离都是可以O(N)时间求出的，注意不要重复计算。接下来就不用说了吧？

// Solution 1: Since it's Manhattan Distance we use, the calculation of x- and y-axis are completely independent. Thus we compute the sum of distances for every x- and y- coordinates. The computation can be done in O(N) time, if you know how to avoid redundancy. Need I say more?

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0296_best-meeting-point_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0296_best-meeting-point_1_AC.cpp)

<hr>

#297 Serialize and Deserialize Binary Tree

// #297 二叉树序列化

描述：设计一种序列化和反序列化二叉树的算法。

// [#297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) Description: Serialize and Deserialize Binary Tree | LeetCode OJ

解法1：其实只要对空指针做适当的标记，任何一种遍历都可以唯一地序列化一棵二叉树。所以，更值得关心的，是如何使序列化后的字符串更短。

// Solution 1: As long as NULL pointer is marked with some special characters, any kind of traversal can unambiguously serialize a binary tree. The length of the serialization output is worth more attention.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0297_serialize-and-deserialize-binary-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0297_serialize-and-deserialize-binary-tree_1_AC.cpp)

<hr>

#298 Binary Tree Longest Consecutive Sequence

// #298 最长二叉树连续序列

描述：给定一棵二叉树，求从上到下最长连续序列的长度。“连续”指公差为1的等差数列。

// [#298](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/) Description: Binary Tree Longest Consecutive Sequence | LeetCode OJ

解法1：遍历呗。

// Solution 1: Traverse it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0298_binary-tree-longest-consecutive-sequence_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0298_binary-tree-longest-consecutive-sequence_1_AC.cpp)

<hr>

#299 Bulls and Cows

// #299 水牛和奶牛

描述：猜数字玩过吧？你猜，我告诉你有几个完全猜对，有几个数字对位置不对。现在，我猜你说。

// [#299](https://leetcode.com/problems/bulls-and-cows/) Description: Bulls and Cows | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0299_bulls-and-cows_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0299_bulls-and-cows_1_AC.cpp)

<hr>

#300 Longest Increasing Subsequence

// #300 最长递增子序列

描述：如题。

// [#300](https://leetcode.com/problems/longest-increasing-subsequence/) Description: Longest Increasing Subsequence | LeetCode OJ

解法1：DP。

// Solution 1: DP.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0300_longest-increasing-subsequence_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0001-0500/0300_longest-increasing-subsequence_1_AC.cpp)
