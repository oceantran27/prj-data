#501 Find Mode in Binary Search Tree 

// #501 找出二叉搜索树的众数

描述：带重复值的二叉搜索树，找出所有众数。

// [#501](https://leetcode.com/problems/find-mode-in-binary-search-tree/) Description: Find Mode in Binary Search Tree | LeetCode OJ

解法1：什么乱七八糟的。

// Solution 1: What the f*.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0501_find-mode-in-binary-search-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0501_find-mode-in-binary-search-tree_1_AC.cpp)

<hr>

#502 IPO

// #502 IPO

描述：给定公司的初始资本，有K个项目，每个项目都有成本和盈利。问通过做项目，最多能把公司的资本扩充到多少？

// [#502](https://leetcode.com/problems/ipo/) Description: IPO | LeetCode OJ

解法1：贪婪。

// Solution 1: Greed is good.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0502_ipo_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0502_ipo_1_AC.cpp)

<hr>

#503 Next Greater Element II

// #503 下一个更大元素2

描述：和之前一样，这次要处理整个数组，而且将数组看成是循环的。

// [#503](https://leetcode.com/problems/next-greater-element-ii/) Description: Next Greater Element II | LeetCode OJ

解法1：还是用栈。

// Solution 1: Use a stack, as always.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0503_next-greater-element-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0503_next-greater-element-ii_1_AC.cpp)

<hr>

#504 Base 7

// #504 7进制

描述：给定一个10进制数，返回7进制数字串。

// #504 #504 Description: Base 7 | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0504_base-7_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0504_base-7_1_AC.cpp)

<hr>

#505 The Maze II

// #505 迷宫2

描述：和之前一样，不过这次求的是最短距离。

// [#505](https://leetcode.com/problems/the-maze-ii/) Description: The Maze II | LeetCode OJ

解法1：搜呗。

// Solution 1: BFS.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0505_the-maze-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0505_the-maze-ii_1_AC.cpp)

<hr>

#506 Relative Ranks

// #506 相对排名

描述：给定分数，求所有人的相对排名。前三名获得金银铜。

// [#506](https://leetcode.com/problems/relative-ranks/) Description: Relative Ranks | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0506_relative-ranks_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0506_relative-ranks_1_AC.cpp)

<hr>

#507 Perfect Number

// #507 完美数

描述：给定一个正整数，如果它等于所有小于它的约束之和，就称其为完美数。请判断一个数是否完美。

// [#507](https://leetcode.com/problems/perfect-number/) Description: Perfect Number | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0507_perfect-number_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0507_perfect-number_1_AC.cpp)

<hr>

#508 Most Frequent Subtree Sum

// #508 最常见子树和

描述：给定二叉树，求最常见的子树和，有多少要多少。

// [#508](https://leetcode.com/problems/most-frequent-subtree-sum/) Description: Most Frequent Subtree Sum | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0508_most-frequent-subtree-sum_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0508_most-frequent-subtree-sum_1_AC.cpp)

<hr>

#513 Find Bottom Left Tree Value

// #513 找出底层最左节点

描述：如题。

// [#513](https://leetcode.com/problems/find-bottom-left-tree-value/) Description: Find Bottom Left Tree Value | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0513_find-bottom-left-tree-value_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0513_find-bottom-left-tree-value_1_AC.cpp)

<hr>

#514 Freedom Trail

// #514 自由之路

描述：给定一个旋转密码锁，上面印的都是字母，密码也是字母。你从某位置出发，可以正反旋转转轮，和对应字母对上后，按按钮输入字母。旋转一格和按钮一次都算是一次操作。问最少需要多少次操作，才能成功输入密码？

// [#514](https://leetcode.com/problems/freedom-trail/) Description: Freedom Trail | LeetCode OJ

解法1：一看就是DP。

// Solution 1: DP at first sight.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0514_freedom-trail_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0514_freedom-trail_1_AC.cpp)

<hr>

#515 Find Largest Value in Each Tree Row

// #515 找出二叉树每行最大的节点

描述：如题。

// [#515](https://leetcode.com/problems/find-largest-value-in-each-tree-row/) Description: Find Largest Value in Each Tree Row | LeetCode OJ

解法1：遍历。

// Solution 1: Traverse it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0515_find-largest-value-in-each-tree-row_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0515_find-largest-value-in-each-tree-row_1_AC.cpp)

<hr>

#516 Longest Palindromic Subsequence

// #516 最长回文子序列

描述：如题。

// [#516](https://leetcode.com/problems/longest-palindromic-subsequence/) Description: Longest Palindromic Subsequence | LeetCode OJ

解法1：长得一脸DP。

// Solution 1: DP all over.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0516_longest-palindromic-subsequence_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0516_longest-palindromic-subsequence_1_AC.cpp)

<hr>

#517 Super Washing Machines

// #517 超级洗衣机

描述：给定一个整数数组，对于每一次操作，你可以任选其中一些元素，这些元素可以同时将1传给一个相邻元素。问最少多少步操作，可以是元素全部相等？

// [#517](https://leetcode.com/problems/super-washing-machines/) Description: Super Washing Machines | LeetCode OJ

解法1：谜之解法。

// Solution 1: Whimsical.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0517_super-washing-machines_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0517_super-washing-machines_1_AC.cpp)

<hr>

#520 Detect Capital

// #520 检查大写

描述：如题。

// [#520](https://leetcode.com/problems/detect-capital/) Description: Detect Capital | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0520_detect-capital_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0520_detect-capital_1_AC.cpp)

<hr>

#521 Longest Uncommon Subsequence I

// #521 最长不常见子序列1

描述：懒得解释。

// [#521](https://leetcode.com/problems/longest-uncommon-subsequence-i/) Description: Longest Uncommon Subsequence I | LeetCode OJ

解法1：愚人节快乐。

// Solution 1: Happy April Fool's Day.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0521_longest-uncommon-subsequence-i_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0521_longest-uncommon-subsequence-i_1_AC.cpp)

<hr>

#522 Longest Uncommon Subsequence II

// #522 最长不常见子序列2

描述：给定一组字符串，找出其中某个字符串的子序列，使得这个序列尽可能长，并且该序列不能是其他字符串的子序列。

// [#522](https://leetcode.com/problems/longest-uncommon-subsequence-ii/) Description: Longest Uncommon Subsequence II | LeetCode OJ

解法1：这题就不算是开玩笑了。照理说可以直接用O(N ^ 2)的代价去两两判断各字符串之间是否存在“A包含B”的情况，但是按照字典序和长度排序以后，可以减少一些计算量。所以就有了如下算法。

// Solution 1: Now, this one can be serious. By checking for "A contains B" relationships in a pairwise manner, we know which string to choose as the LUS. Sorting is for reducing some unnecessary amount of calculation.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0522_longest-uncommon-subsequence-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0522_longest-uncommon-subsequence-ii_1_AC.cpp)

<hr>

#523 Continuous Subarray Sum

// #523 连续子数组和

描述：给定数组和一个数K，求是否存在子数组和为K的倍数。

// [#523](https://leetcode.com/problems/continuous-subarray-sum/) Description: Continuous Subarray Sum | LeetCode OJ

解法1：哈希。

// Solution 1: Hash it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0523_continuous-subarray-sum_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0523_continuous-subarray-sum_1_AC.cpp)

<hr>

#524 Longest Word in Dictionary through Deleting

// #524 字典中删除字母而成的最长单词

描述：给定一个长单词和一个字典。找出是长单词子序列的字典中的最长单词。

// [#524](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/) Description: Longest Word in Dictionary through Deleting | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0524_longest-word-in-dictionary-through-deleting_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0524_longest-word-in-dictionary-through-deleting_1_AC.cpp)

<hr>

#525 Contiguous Array

// #525 连续数组

描述：给定一个01数组，找出0和1数量相同的最长子数组。

// [#525](https://leetcode.com/problems/contiguous-array/) Description: Contiguous Array | LeetCode OJ

解法1：不一样的水题，一样的水。

// Solution 1: Count it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0525_contiguous-array_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0525_contiguous-array_1_AC.cpp)

<hr>

#526 Beautiful Arrangement

// #526 好排列

描述：对于1~N的排列，如果对于所有下标K，第K位的元素都是K的约数或倍数，则称为一个好排列。那么，给定N，共有多少个好排列？

// [#526](https://leetcode.com/problems/beautiful-arrangement/) Description: Beautiful Arrangement | LeetCode OJ

解法1：直接暴力搜，因为能搜的空间其实很小。

// Solution 1: Brute-force DFS, as the space for brute-force is small enough.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0526_beautiful-arrangement_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0526_beautiful-arrangement_1_AC.cpp)

<hr>

#527 Word Abbreviation

// #527 单词缩写

描述：给定一些互不重复的单词，要求为每个提供一个缩写。缩写的规则是{前缀 + 中间的长度 + 尾字母}，在保证各缩写无二义性的情况下，务必使缩写尽量短。如果缩写没什么卵用，就甭缩。

// [#527](https://leetcode.com/problems/word-abbreviation/) Description: Word Abbreviation | LeetCode OJ

解法1：这题难度写的是Hard，然而一看就没觉得多难。想了想，既然涉及到找前缀，很自然地会想到按字典序去排序，于是就有了如下解法。注意comparator的写法，这个是关键。

// Solution 1: This problem is rated "Hard", but it takes just a glimpse or two to tell it's no trouble at all. Since you have to look for longest common prefix amongst words, it should be reasonable to sort things lexicographically, thus we have the solution down here. Pay close attention to the comparator, which is the key part.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0527_word-abbreviation_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0527_word-abbreviation_1_AC.cpp)

<hr>

#529 Minesweeper

// #529 扫雷

描述：给定一个扫雷棋盘，完成一次点击。

// [#529](https://leetcode.com/problems/minesweeper/) Description: Minesweeper | LeetCode OJ

解法1：搜。

// Solution 1: DFS.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0529_minesweeper_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0529_minesweeper_1_AC.cpp)

<hr>

#530 Minimum Absolute Difference in BST

// #530 二叉搜索树最小差值

描述：给定一棵二叉搜索树，求节点的最小差值。

// [#530](https://leetcode.com/problems/minimum-absolute-difference-in-bst/) Description: Minimum Absolute Difference in BST | LeetCode OJ

解法1：中序遍历。

// Solution 1: Inorder traversal.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0530_minimum-absolute-difference-in-bst_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0530_minimum-absolute-difference-in-bst_1_AC.cpp)

<hr>

#531 Lonely Pixel I 

// #531 孤独的黑点1

描述：如果一个黑点所在的行和列都没有第二个黑点，则称为孤独黑点。给定一个黑白矩阵，找出所有孤独黑点，返回个数。

// [#531](https://leetcode.com/problems/lonely-pixel-i/) Description: Lonely Pixel I | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0531_lonely-pixel-i_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0531_lonely-pixel-i_1_AC.cpp)

<hr>

#532 K-diff Pairs in an Array

// #532 差为K的数对

描述：给定数组，找出差为K的不重复数对。

// [#532](https://leetcode.com/problems/k-diff-pairs-in-an-array/) Description: K-diff Pairs in an Array | LeetCode OJ

解法1：哈希。

// Solution 1: Hash it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0532_k-diff-pairs-in-an-array_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0532_k-diff-pairs-in-an-array_1_AC.cpp)

<hr>

#533 Lonely Pixel II

// #533 孤独黑点2

描述：对于某个黑点，如果那一列里还有K - 1个黑点，而且这一行也还有K - 1个黑点，并且这K - 1行恰好和这行长得一模一样，则这K个都称为孤独黑点。求所有孤独黑点的个数。

// [#533](https://leetcode.com/problems/lonely-pixel-ii/) Description: Lonely Pixel II | LeetCode OJ

解法1：无聊。

// Solution 1: Boring.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0533_lonely-pixel-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0533_lonely-pixel-ii_1_AC.cpp)

<hr>

#535 Encode and Decode TinyURL

// #535 短网址编解码

描述：设计一个短网址的编解码器。

// [#535](https://leetcode.com/problems/encode-and-decode-tinyurl/) Description: Encode and Decode TinyURL | LeetCode OJ

解法1：然而并没写。

// Solution 1: Didn't do it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0535_encode-and-decode-tinyurl_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0535_encode-and-decode-tinyurl_1_AC.cpp)

<hr>

#536 Construct Binary Tree from String

// #536 由字符串构造二叉树

描述：给定二叉树序列化的字符串，子树用“()”括起来，按照先左后右的原则，重建出二叉树。

// [#536](https://leetcode.com/problems/construct-binary-tree-from-string/) Description: Construct Binary Tree from String | LeetCode OJ

解法1：用了个栈。

// Solution 1: Get yourself a stack.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0536_construct-binary-tree-from-string_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0536_construct-binary-tree-from-string_1_AC.cpp)

<hr>

#537 Complex Number Multiplication

// #537 复数相乘

描述：给定两个复数，做乘法，输入输出都是字符串。

// [#537](https://leetcode.com/problems/complex-number-multiplication/) Description: Complex Number Multiplication | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0537_complex-number-multiplication_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0537_complex-number-multiplication_1_AC.cpp)

<hr>

#538 Convert BST to Greater Tree

// #538 将二叉搜索树转化为较大树

描述：给定一棵二叉搜索树，将每个节点的值变为对应的中序遍历后缀和。

// [#538](https://leetcode.com/problems/convert-bst-to-greater-tree/) Description: Convert BST to Greater Tree | LeetCode OJ

解法1：遍历呗。

// Solution 1: Pay a visit.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0538_convert-bst-to-greater-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0538_convert-bst-to-greater-tree_1_AC.cpp)

<hr>

#539 Minimum Time Difference

// #539 最小时间差

描述：给定一堆时间，求最小时间差。

// [#539](https://leetcode.com/problems/minimum-time-difference/) Description: Minimum Time Difference | LeetCode OJ

解法1：排个序。

// Solution 1: Sort it out.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0539_minimum-time-difference_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0539_minimum-time-difference_1_AC.cpp)

<hr>

#540 Single Element in a Sorted Array

// #540 有序数组中的落单元素

描述：给定一个有序数组，其中只有一个元素出现一次，其余各出现两次。找出落单元素。

// [#540](https://leetcode.com/problems/single-element-in-a-sorted-array/) Description: Single Element in a Sorted Array

解法1：二分。

// Solution 1: Binary search.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0540_single-element-in-a-sorted-array_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0540_single-element-in-a-sorted-array_1_AC.cpp)

<hr>

#541 Reverse String II

// #541 反转字符串2

描述：给定一个字符串，对于每2k个字符，反转前k个。结尾部分不足k个的话，有多少转多少。

// [#541](https://leetcode.com/problems/reverse-string-ii/) Description: Reverse String II | LeetCode OJ

解法1：水题。

// Solution 1: Piece of sponge cake.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0541_reverse-string-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0541_reverse-string-ii_1_AC.cpp)

<hr>

#542 01 Matrix

// #542 01矩阵

描述：给定01矩阵，对于每个1，求离它最近的0的曼哈顿距离。

// [#542](https://leetcode.com/problems/01-matrix/) Description: 01 Matrix | LeetCode OJ

解法1：不管用不用队列，这玩意儿都叫BFS。只要是图论相关的问题，总要记住一点：尽量避免重复计算，因为这往往意味着时空复杂度在阶数上的差别。

// Solution 1: Using queue or not, it is called BFS. Bear in mind for all problems involving graph theory: avoid all redundant calculations whenever you can, as this usually means the difference in orders in terms of time and space complexities.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0542_01-matrix_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0542_01-matrix_1_AC.cpp)

<hr>

#543 Diameter of Binary Tree

// #543 二叉树直径

描述：给定一棵二叉树，求任意两个节点的最长路径长度。

// [#543](https://leetcode.com/problems/diameter-of-binary-tree/) Description: Diameter of Binary Tree | LeetCode OJ

解法1：水题。

// Solution 1: Piece of waffle.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0543_diameter-of-binary-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0543_diameter-of-binary-tree_1_AC.cpp)

<hr>

#544 Output Contest Matches

// #544 输出比赛安排

描述：给定2 ^ K支队伍，编号1~2 ^ K，要你为他们排比赛场次。要求按照弱强组合的方式去排。用括号递归包含，括号内用逗号分隔，输出比赛安排。

// [#544](https://leetcode.com/problems/output-contest-matches/) Description: Output Contest Matches | LeetCode OJ

解法1：老实说，这题最大的难度在于读懂题目。我看了半天样例3才搞懂规律。

// Solution 1: Honestly, the major challenge of this problem is to understand what's going on. It took me a while to see the pattern in example 3.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0544_output-contest-matches_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0544_output-contest-matches_1_AC.cpp)

<hr>

#546 Remove Boxes

// #546 拿箱子

描述：有一排颜色不同的箱子，每次允许你选相邻的颜色相同的K个箱子，一次性拿走将给你K*K的奖分。如此拿箱子直到全部拿完，求最高得分。

// [#546](https://leetcode.com/problems/remove-boxes/) Description: Remove Boxes | LeetCode OJ

解法1：第一反应肯定是暴力搜索，然而效率太低不能过。于是下一思路就是DP，然而我想了半天也没找出很好的状态表示跟递推关系。于是最终看了看网上的解法，请参见代码里的链接。

// Solution 1: The first solution should be brute-force DFS, too slow to be acceptable. So the next idea should be DP. Yet no good state represetation or transition came to my mind after long thought. Had to giving to Internet references, please see the URL in my code.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0546_remove-boxes_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0546_remove-boxes_1_AC.cpp)

<hr>

#547 Friend Circles

// #547 朋友圈

描述：给定一个表示社交关系的01方阵，求连通分量个数。

// [#547](https://leetcode.com/problems/friend-circles/) Description: Friend Circles | LeetCode OJ

解法1：并查集。

// Solution 1: Union-find set.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0547_friend-circles_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0547_friend-circles_1_AC.cpp)

<hr>

#551 Student Attendance Record I

// #551 学生出勤记录1

描述：给定一个学生的出勤记录，至多允许一次缺勤和连续两次迟到，问出勤记录是否合格。

// [#551](https://leetcode.com/problems/student-attendance-record-i/) Description: Student Attendance Record I | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0551_student-attendance-record-i_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0551_student-attendance-record-i_1_AC.cpp)

<hr>

#552 Student Attendance Record II

// #552 学生出勤记录2

描述：按照之前给定的出勤规定，给定长度N，求长度为N的合格出勤记录总共有多少种。鉴于结果可能非常大，结果膜10^9+7。

// [#552](https://leetcode.com/problems/student-attendance-record-ii/) Description: Student Attendance Record II | LeetCode OJ

解法1：这题就有意思了，一道不算简单的组合数学题。期初我想找找有没有什么数学解法，或者更通用的解法，但是尝试许久无果，最终搞出了这么个笨办法。提示一下，考虑“不缺勤”和“一次缺勤”两种情况。

// Solution 1: An interesting combinatorial problem, not so easy, though. I tried hard to push myself to some more mathematical and general-purpose solution

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0552_student-attendance-record-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0552_student-attendance-record-ii_1_AC.cpp)

<hr>

#553 Optimal Division

// #553 最优除法

描述：给定一个除法表达式，允许你在其中添加若干括号，使得结果最大。请输出结果最大的相应表达式。

// [#553](https://leetcode.com/problems/optimal-division/) Description: Optimal Division | LeetCode OJ

解法1：显然这题要DP，但有一点要搞清楚，我们不但需要求出最大值，还需要最小值。因为括号就是最大值和最小值之间的关联。

// Solution 1: Apparently it's about DP, but make no mistake, that we need more than just the maximum, but the minimum as well. The brackets are the link between them.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0553_optimal-division_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0553_optimal-division_1_AC.cpp)

<hr>

#554 Brick Wall

// #554 砖墙

描述：给定一面砖墙，从上到下每一行都由长度不一的转头连成，但保证总长度一致。现在要你从上往下画一条直线，问如何划线才能穿过最少的砖头。擦边不算穿过，不允许在两边界划线。

// [#554](https://leetcode.com/problems/brick-wall/) Description: Brick Wall | LeetCode OJ

解法1：有意思，想了大概十分钟，原来是哈希。

// Solution 1: Interesting. Took me about ten minutes to figure out it's about hashing.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0554_brick-wall_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0554_brick-wall_1_AC.cpp)

<hr>

#556 Next Greater Element III

// #556 更大数3

描述：给定一个正整数，求用相同数字构成的下一个更大数。如果在32位整数范围内没有更大的，就返回-1。

// [#556](https://leetcode.com/problems/next-greater-element-iii/) Description: Next Greater Element III | LeetCode OJ

解法1：next_permutation。

// Solution 1: next_permutation.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0556_next-greater-element-iii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0556_next-greater-element-iii_1_AC.cpp)

<hr>

#557 Reverse Words in a String III

// #557 反转字符串中的单词3

描述：给定一句话，反转每个词，但保持词序。

// [#557](https://leetcode.com/problems/reverse-words-in-a-string-iii/) Description: Reverse Words in a String III | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0557_reverse-words-in-a-string-iii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0557_reverse-words-in-a-string-iii_1_AC.cpp)

<hr>

#560 Subarray Sum Equals K

// #560 和为K的子数组

描述：给定一个数组，求和为K的子数组个数。

// [#560](https://leetcode.com/problems/subarray-sum-equals-k/) Description: Subarray Sum Equals K | LeetCode OJ

解法1：哈希。

// Solution 1: Hash it.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0560_subarray-sum-equals-k_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0560_subarray-sum-equals-k_1_AC.cpp)

<hr>

#561 Array Partition I

// #561 数组划分1

描述：给定一个长度为2N的数组，将其分为N对(Ai, Bi)，使得min(Ai, Bi)的求和最大。

// [#561](https://leetcode.com/problems/array-partition-i/) Description: Array Partition I | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0561_array-partition-i_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0561_array-partition-i_1_AC.cpp)

<hr>

#563 Binary Tree Tilt

// #563 二叉树倾斜（什么玩意儿）

描述：无可奉告。

// [#563](https://leetcode.com/problems/binary-tree-tilt/) Description: Binary Tree Tilt | LeetCode OJ

解法1：无聊。

// Solution 1: Boring.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0563_binary-tree-tilt_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0563_binary-tree-tilt_1_AC.cpp)

<hr>

#564 Find the Closest Palindrome

// #564 最近回文数

描述：给定一个整数，求离它最近的回文数，自身除外。

// [#564](https://leetcode.com/problems/find-the-closest-palindrome/) Description: Find the Closest Palindrome | LeetCode OJ

解法1：既然是回文数嘛，分成两半想。如果有必要，还得考虑中间一位。

// Solution 1: Palindromes should be tackled by two halves. Take the mid digit into account if necessary.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0564_find-the-closest-palindrome_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0564_find-the-closest-palindrome_1_AC.cpp)

<hr>

#565 Array Nesting

// #565 数组嵌套

描述：给定一个0~N-1的排列，求其循环长度的最大值。

// [#565](https://leetcode.com/problems/array-nesting/) Description: Array Nesting

解法1：判断循环长度的时候，只需要对每个循环遍历一次，遍历过程中把节点逐个标记为已访问，边标记边数长度即可。

// Solution 1: Traverse every cycle to count its length. Mark every node in the cycle as visited as you go, count the length during the process.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0565_array-nesting_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0565_array-nesting_1_AC.cpp)

<hr>

#566 Reshape the Matrix

// #566 矩阵变形

描述：实现Matlab中的reshape函数，将矩阵变换尺寸。

// [#566](https://leetcode.com/problems/reshape-the-matrix/) Description: Reshape the Matrix | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0566_reshape-the-matrix_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0566_reshape-the-matrix_1_AC.cpp)

<hr>

#567 Permutation in String

// #567 字符串中的排列

描述：给定字符串s1和s2，问s2中是否存在一个子串，使得s1是该子串的排列。

// [#567](https://leetcode.com/problems/permutation-in-string/) Description: Permutation in String | LeetCode OJ

解法1：滑动窗口，统计diff即可。当diff为0时表示完全匹配，否则失败。

// Solution 1: Keep a running statistics of diffs with a sliding window. Return true when diff reaches 0, false otherwise.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0567_permutation-in-string_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0567_permutation-in-string_1_AC.cpp)

<hr>

#572 Subtree of Another Tree

// #572 另一棵树的子树

描述：给定两棵二叉树S和T，问T是否为S的子树。

// [#572](https://leetcode.com/problems/subtree-of-another-tree/) Description: Subtree of Another Tree | LeetCode OJ

解法1：直观的解法当然是递归搜索，但考虑匹配失败时的回溯，就知道此方法过于暴力，效率太差。于是怎么办？如果字符串匹配可以达到O(N)时间，二叉树序列化也可以O(N)搞定，那么两者配合起来就是O(N)解法了。注意序列化算法的设计，不能存在二义性，否则字符串匹配会出错。

// Solution 1: An intuitive approach would be recursive search. Considering the backtracking required for mismatch, this algorithmd will be much too brute-force. What then? Think about O(N) string matching algorithms and O(N) tree serialization algorithms, combined into one, that's the answer. Note that the serialization method you choose has to be perfectly unambiguous, otherwise there're gonna be bugs with string matching.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0572_subtree-of-another-tree_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0572_subtree-of-another-tree_1_AC.cpp)

<hr>

#575 Distribute Candies

// #575 发糖果

描述：给定2N个数，将其分成N和N两堆。问其中任一堆，最多可能有多少个不重复的数。

// [#575](https://leetcode.com/problems/distribute-candies/) Description: Distribute Candies | LeetCode OJ

解法1：水题。

// Solution 1: Trivial.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0575_distribute-candies_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0575_distribute-candies_1_AC.cpp)

<hr>

#576 Out of Boundary Paths

// #576 出界路径

描述：给定一个矩阵，从界内某一点(sx, sy)出发，每次允许上下左右走一格，问走出边界总共有多少种方法。路径中最后一步必须走出界，其他情况必须在界内。如果允许至多走N步，求所有可能的走法，结果对某大质数取膜。

// [#576](https://leetcode.com/problems/out-of-boundary-paths/) Description: Out of Boundary Paths | LeetCode OJ

解法1：这题有意思，应该是典型的DP，状态转移也并不复杂，一步一步走即可。关键是最后一步必须走出边界，如果为了统计最后一步的结果就把矩阵扩大一圈，显然麻烦了点。于是，我们可以倒退一步，统计走之前的状态。具体实现请看代码。

// Solution 1: An interesting problem, should be DP at first sight. The state transition looks obvious enough from a step-by-step approach. One little problem is with the last step, where you have to step out of bound. It would be easier to keep count of the states one step behind, so you don't have to include the area immediately outside the boundary. For more details please read the code.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0576_out-of-boundary-paths_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0576_out-of-boundary-paths_1_AC.cpp)

<hr>

#581 Shortest Unsorted Continuous Subarray

// #581 最短连续无序子数组

描述：懒得说。

// [#581](https://leetcode.com/problems/shortest-unsorted-continuous-subarray/) Description: Shortest Unsorted Continuous Subarray | LeetCode OJ

解法1：我去，定语这么长，唬我啊？还不是水题。美小圆旧黄法国木书房，服不服？

// Solution 1: Just a water problem, you say a hammer. 

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0581_shortest-unsorted-continuous-subarray_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0581_shortest-unsorted-continuous-subarray_1_AC.cpp)

<hr>

#582 Kill Process

// #582 结束进程

描述：给定一个进程树，请结束某个进程p以及它的所有子进程，返回所有被终止的进程。

// [#582](https://leetcode.com/problems/kill-process/) Description: Kill Process | LeetCode OJ

解法1：并查集，将目标进程p设置为孤立根节点即可。该进程树的所有节点都被终止。

// Solution 1: Use disjoint set, set the node p as the root of an orphan tree. All process nodes on that tree shall be terminated.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0582_kill-process_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0582_kill-process_1_AC.cpp)

<hr>

#583 Delete Operation for Two Strings

// #583 两字符串的删除操作

描述：给定两个字符串，允许你每次从某串删除一个字符。问至少经过多少操作，可使两字符串相同。

// [#583](https://leetcode.com/problems/delete-operation-for-two-strings/) Description: Delete Operation for Two Strings | LeetCode OJ

解法1：最长公共子序列。

// Solution 1: LCS.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0583_delete-operation-for-two-strings_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0583_delete-operation-for-two-strings_1_AC.cpp)

<hr>

#587 Erect the Fence

// #587 树篱笆

描述：给定二维平面上一些点，求凸包。要求能够处理共线的情况。

// [#587](https://leetcode.com/problems/erect-the-fence/) Description: Erect the Fence | LeetCode OJ

解法1：按照标准的Graham scan算法实现了一份，发现结果总会漏掉一些共线的点。仔细分析了以后，发现关键在于Graham scan对于共线的点是采取由近到远的排序方法，对于数组末尾的几个共线的点，这种排序方法会把中间的点全部舍弃，所以我的解法在结尾单独进行了处理，请看代码。

// Solution 1: After writing a standard version of Graham scan, I found the result would always leave out some colinear points at the tail. With some careful analysis, I noticed that the bug lies in that Graham scan sorts all colinear points by distance in ascending order, for the last few colinear points, the algorithm will pick none but the farthest one, leaving out the rest. I fixed this case with some special treatment at the end. Please read the code.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0587_erect-the-fence_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0587_erect-the-fence_1_AC.cpp)

<hr>

#588 Design In-Memory File System

// #588 设计内存文件系统

描述：设计一个常驻内存的简易文件系统。支持原始的mkdir、ls、文件读写。

// [#588](https://leetcode.com/problems/design-in-memory-file-system/) Description: Design In-Memory File System | LeetCode OJ

解法1：这是一道系统设计题，不是算法题。显然，你不可能50行代码搞定一道设计题。动手吧。碰见系统设计题，多想想函数式编程、面向对象编程、设计模式等等，说不定用得上。

// Solution 1: This is a system design problem, not an algorithmic one. Apparently you don't solve a system design problem within 50 lines of code. So get to it. Whenever dealing with system design problems, try and think about Functional Programming, Object-Oriented Programming, Design Patterns or so, might come in handy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0588_design-in-memory-file-system_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0588_design-in-memory-file-system_1_AC.cpp)

<hr>

#591 Tag Validator

// #591 标签校验器

描述：设计一个规则很复杂的标签校验器。不会正则表达式请直接投降，缴枪不杀。

// [#591](https://leetcode.com/problems/tag-validator/) Description: Tag Validator

解法1：我想问问，这么复杂的要求，不用正则表达式，自己写个parser，得花多少工夫？有一点值得注意，编译一个正则相当于创建一个自动机，编译时间长，但运行效率较高。

// Solution 1: They demand regular expression for this one, you know? If you got enough time and patience to build a parser of your own, suit yourself. One thing worth noting, is that a compiled regex pattern is an automaton, which runs fast at the cost of relatively long compile time.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0591_tag-validator_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0591_tag-validator_1_AC.cpp)

<hr>

#592 Fraction Addition and Subtraction

// #592 分数加减法

描述：给定一个分数加减的算式，求结果。

// [#592](https://leetcode.com/problems/fraction-addition-and-subtraction/) Description: Fraction Addition and Subtraction | LeetCode OJ

解法1：面向对象编程。

// Solution 1: OOP.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0592_fraction-addition-and-subtraction_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0592_fraction-addition-and-subtraction_1_AC.cpp)

<hr>

#593 Valid Square

// #593 判断正方形

描述：给定二维平面上四个点，判断是否构成正方形。

// [#593](https://leetcode.com/problems/valid-square/) Description: Valid Square | LeetCode OJ

解法1：水题。

// Solution 1: Easy.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0593_valid-square_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0593_valid-square_1_AC.cpp)

<hr>

#594 Longest Harmonious Subsequence

// #594 最长和谐子序列

描述：给定一个数组，求一个最长子序列，要求其中最大值和最小值之差恰好为1。

// [#594](https://leetcode.com/problems/longest-harmonious-subsequence/) Description: Longest Harmonious Subsequence | LeetCode OJ

解法1：水题。

// Solution 1: Easy. 

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0594_longest-harmonious-subsequence_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0594_longest-harmonious-subsequence_1_AC.cpp)

<hr>

#598 Range Addition II

// #598 区间加法2

描述：给定一个NxM的矩阵，初始全为0。每次操作(x, y)将前x行y列的矩阵中所有元素加1。问执行完所有操作后，矩阵中有多少个元素等于最大值。

// [#598](https://leetcode.com/problems/range-addition-ii/) Description: Range Addition II

解法1：脑筋急转弯。

// Solution 1: Brainteaser.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0598_range-addition-ii_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0598_range-addition-ii_1_AC.cpp)

<hr>

#599 Minimum Index Sum of Two Lists

// #599 两数组的最小下标和

描述：给定两无重复元素的数组，求其共有元素中，对应位置下标和最小的。如果有多个元素下标和相同，全部输出。

// [#599](https://leetcode.com/problems/minimum-index-sum-of-two-lists/) Description: Minimum Index Sum of Two Lists

解法1：水题，不过C++写起来不是很方便，用Python可能两行就搞定了。

// Solution 1: Trivial for Python, a little work for C++.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0599_minimum-index-sum-of-two-lists_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0599_minimum-index-sum-of-two-lists_1_AC.cpp)

<hr>

#600 Non-negative Integers without Consecutive Ones

// #600 不含连续1的非负整数

描述：给定一个数N，求所有不超过N，而且二进制表示中不含连续1的非负整数个数。

// [#600](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/) Description: Non-negative Integers without Consecutive Ones

解法1：这题不简单。按照二进制位数找规律，会发现其符合斐波那契数列。然后小心推导DP公式即可。反正我错的一塌糊涂，各种debug终于通过。任何DP类型的问题，都要遵循“多动脑，少动手”的原则。

// Solution 1: A challenging one. Analyse the binary numbers by their number of digits, you'll find Fibonacci Sequence is the key. Deduce the DP recurrence relation carefully because you start coding. I for one, went through a lot of bugs and debugging before finally locking an AC. Always remember to think more and code less for such DP problems.

[代码1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0600_non-negative-integers-without-consecutive-ones_1_AC.cpp)

// [Code 1](https://github.com/zhuli19901106/leetcode-zhuli/blob/master/algorithms/0501-1000/0600_non-negative-integers-without-consecutive-ones_1_AC.cpp)
