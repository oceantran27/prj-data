# LeetCode 一句话题解 - 1501-2000

[返回目录](./README.md)

- [LeetCode 一句话题解 - 1501-2000](#leetcode-一句话题解---1501-2000)
  - [1501 - 1600](#1501---1600)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1501-2000](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1501-2000)

## 1501 - 1600

1502 Can Make Arithmetic Progression From Sequence

题意：给定数组nums，请问能否排序变成一个等差数列？

难度：easy

解法：那就<b>排序</b>。

<hr>

1503 Last Moment Before All Ants Fall Out of a Plank

题意：有一些蚂蚁在木板上走，<b>向左或向右</b>，速度都是1。初始位置为`left[i]`和`right[j]`，分别表示向左或向右的蚂蚁的位置。如果两只蚂蚁<b>相遇</b>，则都<b>回头继续走</b>。请问经过多长时间，所有蚂蚁都走出木板边界？

难度：medium

解法：其实是个<b>智力题</b>。两蚂蚁<b>碰撞</b>，等效于<b>穿过</b>了。因此你可以认为，所有蚂蚁<b>就这么一直走</b>，走出边界就行了。计算<b>max时间</b>即可。总代价`O(n)`。

<hr>

1504 Count Submatrices With All Ones

题意：给定m x n的01矩阵，请统计全为1的子矩阵个数。

难度：medium

解法：方法有很多种，但大致的复杂度都是`O(n^3)`。比如我用<b>前i行的每个j列</b>的<b>1个数</b>做累加，可以得到一个数组。但如果当前行的j列是<b>0</b>，则累加值<b>清零</b>。比如当前累加值是`[3,0,1,5,2]`。对于j=3，<b>值5</b>的位置。我<b>往回倒推</b>，看看以5作为<b>右下角</b>，且宽度为`1,2,3,...`的矩形分别有多少个。统计为[5,1,0]个。再看<b>值2</b>的位置，统计为[2,2,1,0]。这个统计总是<b>单调递减</b>的。如此，对于一行的统计代价是O(n^2)，因此总代价是`O(n^3)`。考虑这个变化过程`3->00->001->0015->00122`。我以前提交的代码，已经看不懂了。但思路肯定大同小异。这题可以转化为<b>84题</b>那样的<b>直方图形状</b>去考虑。

<hr>

1506 Find Root of N-Ary Tree

题意：给定n叉树的所有节点，已知这些节点属于同一棵树。请找出<b>根节点</b>。

难度：medium

解法：付费题。`O(1)`空间的加法我没想到。但常规解法很容易，可以用并查集，把`parent->child`关系转化为`dj[child]=parent`。这样，就可以<b>向上走到顶</b>，顶部就是根节点。总代价`O(n)`。

<hr>

1507 Reformat Date

题意：给定类似“20th Oct 2052”这样的日期格式，转化为“YYYY-MM-DD”格式。

难度：easy

解法：水题，不过略麻烦。

<hr>

1508 Range Sum of Sorted Subarray Sums

题意：给定数组`nums`，求它的所有子数组和，并把值升序排列，得到一个数组`sm`。请求出sum(sm[left-1:right])。结果模`1e9+7`返回。

难度：medium

解法：这题有意思，乍一看没什么思路。显然你不能<b>直接穷举</b>，因为太多了。想了半天，确实没什么思路。然后就<b>真穷举了</b>，然后就<b>真过了</b>。总代价就算`O(n^2*logn)`吧。

<hr>

1509 Minimum Difference Between Largest and Smallest Value in Three Moves

题意：给定数组nums，你可以做三次操作。每次允许任选一个元素，改为任意值。求`min(max(nums)-min(nums))`。

难度：medium

解法：其实就是让元素尽可能<b>靠拢</b>。如果`n<4`，答案直接就是0。对于`n>=4`，这其实等效于<b>丢弃3个元素</b>。那我们考虑对nums<b>排序</b>，从前面丢x个，从后面丢y个，且`x+y=3`。求4种丢法，其中的<b>差值最小值</b>。这题几乎都在动脑上，代码很短。可以算个<b>小智力题</b>。

<hr>

1512 Number of Good Pairs

题意：给定数组nums，请求出`i<j,nums[i]==nums[j]`的对数。

难度：easy

解法：哈希计数，求和即可。如果`mm[x]=cc`，则`cc*(cc-1)/2`。

<hr>

1514 Path with Maximum Probability

题意：给定无向图，每条边都有个[0,1]的概率。连续走边，概率<b>累乘</b>。给定起点src和终点dst，请求出一条概率最大的路径，返回概率。

难度：medium

解法：这相当于是<b>带权最长路径</b>？不对，这其实是<b>最短路径</b>。因为你要取`-log()`。题目要求<b>累乘概率最大</b>，取`-log()`之后就成了<b>累加总和最小</b>。剩下就是<b>Dijkstra算法</b>了。因为算法规定不能处理<b>负权</b>，取`-log()`之后也恰好<b>没有负权</b>，完美。出这题的人，还<b>挺有创意的</b>。

<hr>

1518 Water Bottles

题意：喝汽水，<b>瓶子换汽水</b>，听过吧？你有x瓶汽水，每y个瓶子可以换1瓶汽水。请问给定x、y，你总共能喝多少瓶？

难度：easy

解法：<b>喝完了换，换完了喝</b>。直到<b>不够换1瓶</b>为止。

<hr>

1519 Number of Nodes in the Sub-Tree With the Same Label

题意：给定一个无向图表示的树，根节点为0。对于每个节点i，请统计i所在的子树里，和i有<b>相同节点值</b>的节点个数。

难度：medium

解法：题目不难，就是题目描述有点<b>看不懂</b>。可以递归遍历这个树，并且保持一个<b>哈希表</b>，来统计不同值的个数。<b>后序遍历</b>，对于统计结果，查找当前节点的val的出现次数。总代价`O(n)`。

<hr>

1522 Diameter of N-Ary Tree

题意：给定n叉树，求树的直径。

难度：medium

解法：其实这个和n叉树，甚至是不是树都无关。<b>图的直径</b>就是<b>最长路径</b>的长度。还是采用<b>搜两次</b>的思路，参见<b>1245题</b>。当然，你如果不想转化为无向图去求解，也可以在树上采用<b>双层递归</b>的写法。两种方法的思路都不难，但<b>实现都略麻烦</b>。总代价`O(n)`。

<hr>

1523 Count Odd Numbers in an Interval Range

题意：给定low、high，统计`[low,high]`范围内奇数的个数。

难度：easy

解法：在<b>水题界</b>也是相当炸裂的存在。

<hr>

1525 Number of Good Ways to Split a String

题意：给定字符串s，请将其分为左右<b>两个子串</b>。要求两边唯一值的个数相同，请求出不同划分的个数。

难度：medium

解法：使用两个哈希表，从`i=0`开始右移。<b>一个增、一个减</b>，更新统计。当两者的`len()`相同，就是符合条件的。总代价`O(n)`。

<hr>

1526 Minimum Number of Increments on Subarrays to Form a Target Array

题意：给定数组target，元素非负。你有一个同长度的数组arr，<b>初始全为0</b>。每次你可以任选一个arr的<b>子数组，给所有元素+1</b>。请问至少多少次操作，可以把arr变成target？

难度：hard

解法：这是个<b>智力题</b>。你可以考虑数组值的<b>升降</b>。比如用类似<b>水位上涨</b>，淹没的思路去做。但这样的<b>模拟算法</b>，很难在`O(n)`时间搞定，也不容易想清楚。比如`[1,2,4,1,0,3,7,2]`，你能看出来有<b>两个小山</b>。那这个+1操作肯定要分两批做，因为<b>子数组无法连到一起</b>。实际上，<b>关键思路</b>极其简单（如果<b>想不到就很难</b>）。只要<b>值上升了</b>，你就要执行`+1`。如果值持平或者下降，你什么都不用做。为什么下降不用管呢？因为上升时你已经+1到达<b>最高点</b>了，那是不是随后下降的位置，你已经<b>“淹没”</b>了？因此就<b>不用重复+1</b>了。总代价`O(n)`。

<hr>

1528 Shuffle String

题意：给定字符串s和位置indices，把`s[i]`按照`indices[i]`重排一下。

难度：easy

解法：水题。

<hr>

1529 Minimum Suffix Flips

题意：给定01串s和target，都长度为n。开始s是全0，每次操作，允许你选择s[i:n]反转。请问至少几次操作，能把s变为target。

难度：medium

解法：其实很好理解，每次我都可以反转右边的一部分。那么我只考虑有几段000111这种连续的0段、1段。我只关心<b>有几段</b>，而<b>不在乎每段有几个</b>。因为我选可以选任意位置反转，每反转一次，就会多出一段01变化。<b>最靠左的0段</b>可以忽略，不需要反转。这题以前是<b>Bulb Switcher</b>的变体题，后来改名字了。总代价`O(n)`。

<hr>

1530 Number of Good Leaf Nodes Pairs

题意：给定二叉树，请求出两节点路径长度不超过distance的<b>节点对个数</b>。

难度：medium

解法：形象上很好理解，但怎么搜效率更高？采取双层递归，遍历x、y两个节点吗？这个思路可以，不过可以做得更直观。我可以遍历，并记下每个节点的路径，用<b>01串</b>表示。比如<b>“010”代表“左右左”</b>。那么“010”和“0011”的距离，就是<b>“10”+“011”的长度</b>，5。也就是<b>去掉公共前缀</b>后的剩余长度和。枚举得到的n个路径串，计算距离。总代价`O(n^2)`。这个方法效率并不高，但<b>有助于理解</b>，这样写代码<b>不容易出错</b>。

<hr>

1534 Count Good Triplets

题意：给定数组arr，请找出`(i,j,k),i<j<k`，使得`|arr[i]-arr[j]|<=a`、`|arr[j]-arr[k]|<=b`、`|arr[i]-arr[k]|<=c`。

难度：easy

解法：不考虑复杂方法了，<b>直接枚举</b>。似乎有更优解法，但<b>思维和实现难度</b>会显著上升，罢了。总代价`O(n^3)`。

<hr>

1535 Find the Winner of an Array Game

题意：给定数组arr，我们每次都比较`arr[0]`和`arr[1]`的大小。大的放到0位置，小的放到n-1位置。不断执行这个比较，直到某个值<b>连续赢k次</b>为止。请返回连赢k次的<b>值</b>。

难度：medium

解法：n可以达到1e5，k则可以非常大。但是我们知道，如果k>=n，则结果一定是`max(arr)`，因为<b>最大值</b>肯定是<b>赢麻了</b>。那么对于`k<n`的情况，我们至多模拟`O(k+n)`次，也能知道结果。因此，直接模拟吧。这个过程因为涉及到“移动到末尾”，用<b>链表</b>实现很高效。真的需要链表吗？<b>不需要。</b>你只要把`arr[0]`和`arr[i]`比较就行了，i可以移动，但`arr[0]`总是赢家的位置。这时，你完全可以<b>无视“交换到末尾”</b>这个操作。总代价`O(n)`。

<hr>

1539 Kth Missing Positive Number

题意：给定一个<b>严格递增</b>的数组，元素都是正数。请返回`1~inf`里，第k个<b>未出现的值</b>。

难度：easy

解法：`O(n)`的枚举做法就不说了。对于二分搜索，我们可以考虑一个值x，我判断x是否出现在`arr`。比如<b>出现</b>，位置是i，则x之前<b>共有`x-i-1`个元素</b>没出现；比如<b>没出现</b>，且`<x`的最大值是y，位置是i，则x是<b>第`x-i-
1`个没出现的元素</b>。这样可以二分搜索，逐渐卡到第k个没出现的值。easy难度，就不要搞那么复杂了。

<hr>

1541 Minimum Insertions to Balance a Parentheses String

题意：给定括号序列s，你可以任意插入<b>左右括号</b>。请求出最小的插入次数，使得序列<b>平衡</b>。注意，这次<b>右括号改为“))”</b>，两个字符。

难度：medium

解法：这是个<b>贪心</b>问题，不用DP。用计数cc表示<b>匹配计数</b>，如果出现`cc<0`，则<b>立刻补充</b>左括号。如果<b>处理完了</b>发现`cc>0`，则补充右括号。不过，这题的右括号是<b>“))”</b>，因此要<b>特殊处理</b>一下。总代价`O(n)`。

<hr>

1544 Make The String Great

题意：给定字符串s，如果相邻字符存在同字母大小写的情况，比如“aAEe”这种，则<b>都删除</b>。持续删除这种对子，直到不存在为止。返回结果。

难度：easy

解法：凡是这种类似<b>祖玛</b>一样的<b>删除+靠拢</b>逻辑，都可以用<b>栈</b>处理。

<hr>

1545 Find Kth Bit in Nth Binary String

题意：给定一种01序列，`s[0]='0',s[i]=s[i-1]+'1'+reverse(inverse(s[i-1]))`。请求出`s[n]`的第k位。

难度：medium

解法：当然不会把完整的`s[n]`算出来，应该<b>倒推</b>。你甚至可以写个<b>尾递归</b>，这样思维上容易理解。`s[n]`的长度是`2^n-1`，其中<b>左中右</b>分别是什么，你都知道。按照这个方式，一步步倒推回去。总代价`O(n)`。

<hr>

1550 Three Consecutive Odds

题意：给定数组arr，请判断是否存在连续3个奇数。

难度：easy

解法：水题。

<hr>

1551 Minimum Operations to Make Array Equal

题意：给定数组arr，`arr[i]=2i+1`。每次操作，你可以选两个元素，执行`arr[i]+=1,arr[j]-=1`。请问至少几次操作，可以使<b>所有元素相等</b>。

难度：medium

解法：一道简单的<b>数学题</b>，你可以把所有数都变成均值。比如`[1,3,5]`变成`[3,3,3]`，`[1,3,5,7]`变成`[4,4,4,4]`。答案就是奇数`(n^2-1)/4`，偶数`n^2/4`。

<hr>

1552 Magnetic Force Between Two Balls

题意：有n个篮子，位置在`position[i]`。你需要选m个篮子放入磁铁。两个磁铁间的吸力是`|x-y|`。请问如何放置，可以使这些球之间的<b>最小吸力最大</b>？返回这个<b>最大值</b>。

难度：medium

解法：C-137，居然还有<b>Rick and Morty</b>的梗。又是<b>minimax问题</b>，考虑二分搜索。比如<b>最小吸力是x</b>，则我们尝试放置m个磁铁，且保持m-1个间隔都`>=x`，看能不能放够m个。用这个<b>判定函数</b>，做<b>二分搜索</b>。总代价`O(nlog(int))`。

<hr>

1556 Thousand Separator

题意：给定整数，每3位加个点。

难度：easy

解法：这是<b>欧洲</b>那边，比如德国的表示法，<b>用点</b>而不是逗号。

<hr>

1557 Minimum Number of Vertices to Reach All Nodes

题意：给定有向图，请返回一个<b>最小的点集</b>，使得所有点都可以从这个点集<b>到达</b>。

难度：medium

解法：很明显，把<b>入度为0的点</b>都收集起来就行了。入度为0，就是拓扑排序的<b>最前面</b>，肯定是从这些点出发<b>遍历整个图</b>。总代价`O(V+E)`。

<hr>

1558 Minimum Numbers of Function Calls to Make Target Array

题意：给定数组nums，开始你有个同长度数组arr，值全为0。你希望通过两种操作，把arr变成nums。第一，单个值加1，`arr[i]+=1`；第二，所有值乘2，`arr*=2`。

难度：medium

解法：我们看个例子，想想怎么变。比如`[3,5,2]`，很显然，奇数一定是`+1`得到的。那么我们必须对应`-1`。2次操作，变为`[2,4,2]`。然后就可以`/2`了，1次操作，变为`[1,2,1]`。因此可以按照这个思路，<b>统计奇数+除以二</b>两步交替进行。总代价`O(nlog(int))`。<b>换种方式</b>，你也可以对每个元素统计`-1`和`/2`的次数。`-1`要`sum()`，`/2`要`max()`。

<hr>

1560 Most Visited Sector in a Circular Track

题意：有<b>一圈</b>赛道，分为n段。有m场比赛，每场比赛的赛段是`[rounds[i-1],rounds[i]]`。请统计被使用次数最多的所有赛段。

难度：easy

解法：题目描述实在<b>太差劲</b>，评论区都骂翻了。绕圈，<b>哈希计数</b>即可。

<hr>

1561 Maximum Number of Coins You Can Get

题意：有3n堆硬币，每堆的个数是`piles[i]`。每次，你可以从中<b>任选3堆</b>。Alice拿`max(3堆)`，你拿`max(2堆)`，剩的给Bob。请问你最多可以拿到多少硬币？

难度：medium

解法：我们先考虑`piles.sort()`，<b>排序</b>之后依次取3堆。这样你总是拿到3堆中的第2个。能比这个更优吗？我找不出更好的，但也不知道怎么<b>数学证明</b>。总代价`O(nlogn)`。

<hr>

1566 Detect Pattern of Length M Repeated K or More Times

题意：给定数组arr，请判断是否存在一个<b>长度m</b>的子数组，在arr中<b>连续重复了k次</b>。

难度：easy

解法：数据量很小，可以直接暴力匹配。但也有个偷懒的办法，你可以把arr转化为字符串，每个元素就作为字符处理。然后用re模块，写个<b>正则匹配</b>。这个还挺有意思，`re.search(r'(.{{{}}})\1{{{}}}'.format(m,k-1), s)`。意思是先<b>捕捉</b>一个<b>m子串</b>，然后让这个子串重复`k-1`次。正则因为有自己的<b>官方优化</b>，会比暴力匹配快很多。

<hr>

1570 Dot Product of Two Sparse Vectors

题意：给定两个<b>稀疏向量</b>，求<b>点乘</b>。

难度：medium

解法：付费题。点乘的计算是`sum(xi*yi)`。既然稀疏，那我们就只保存`(i,val)`<b>非0值</b>的记录。然后按照哈希表的方式，<b>求交集</b>。相乘求和即可。

<hr>

1572 Matrix Diagonal Sum

题意：给定<b>方阵</b>，请求出正反对角线元素之和。

难度：easy

解法：水题。

<hr>

1574 Shortest Subarray to be Removed to Make Array Sorted

题意：给定数组arr，你可以从中删除一个子数组，使得剩下的部分升序排列。请返回删除的<b>最小长度</b>。

难度：medium

解法：我以前没想出`O(n)`解法，这次想出来了。以前那个思路就不讲了，我们用双指针`i=0,j=后缀升序排列的第一个位置`。比如`[1,2,3,10,4,2,3,5]`，则`i=0,j=5`。然后<b>i位置</b>表示删除子数组的<b>左边界</b>，`j-1`就是删除的右边界。i前进时，j也前进，而且<b>不会回头</b>。因此总代价是`O(n)`。

<hr>

1575 Count All Possible Routes

题意：有一条路上有n个城市，位置是`locations[i]`。你从`src`出发，经过一些城市到达`dst`。已知你开始有`fuel`汽油，每次移动的耗油是从x到y耗油`|x-y|`。如果你在任何位置，汽油都<b>不能为负</b>，但是你可以<b>重复访问</b>任何城市，包括起点终点。请求出能成功到达的<b>路径种类数</b>，结果模`1e9+7`返回。

难度：hard

解法：城市数量最多100，这显然不能<b>暴力搜索</b>。那么关键是什么？关键是可以<b>重复访问</b>。这就把思路变成<b>DP</b>，而不是穷举搜索了。我们以<b>城市数、剩余油量</b>，去做DP。定义`dp[i][j]`为<b>剩余油量i</b>，且<b>最后城市是j</b>的种类。剩下的<b>状态转移</b>就不说了。为什么选油量？因为<b>fuel只有200</b>，location太大了，用location没法做。总代价`O(f*n^2)`。

<hr>

1576 Replace All ?'s to Avoid Consecutive Repeating Characters

题意：给定字符串，包含字母和“?”。请将<b>问号</b>都替换为<b>字母</b>，使得相邻字符都不同。返回任意的有效结果。

难度：easy

解法：水题。

<hr>

1578 Minimum Time to Make Rope Colorful

题意：给定n个气球，每个有颜色`colors[i]`。你需要拿走一些气球，使得剩下的相邻气球都不同色。拿走每个气球的代价是`neededTime[i]`。请求出最小总代价。

难度：medium

解法：这题不要<b>误解成DP问题</b>。你可以把<b>连续的同色气球</b>看成1个。因为你只能留1个。那就留<b>`needTime`最大</b>的那个，剩下的<b>都要拿走</b>。按这个逻辑，求和即可。总代价`O(n)`。

<hr>

1579 Remove Max Number of Edges to Keep Graph Fully Traversable

题意：给定一个无向图，存在<b>三种边</b>：A可访问，B可访问，AB都可访问。现在允许你删除一些边，使得剩余的边依然能让A、B<b>从所有点到达所有点</b>。请返回删除的最大边数。

难度：hard

解法：这题很难，主要难在你可能会往一些<b>更难的方向</b>去想，然后就<b>想不出来</b>了。我考虑过<b>割边</b>问题，显然graph cut不简单，我甚至不知道一个具体的<b>求割边算法</b>。这条路走不通，后来看了评论区，说<b>并查集</b>。我<b>完全想不到</b>，尝试理解了一下。其实这题的巧妙在于边有<b>三种类型</b>，A型、B型、AB型。我们<b>先考虑A</b>，`A+AB`型的边。那么，当一条边导致dj的<b>连通分量减少</b>，说明`union()`成功了，我们<b>需要这条边</b>。那剩下的边，就是<b>多余边</b>了。同理，对`B+AB`也执行一次。要注意AB部分<b>不要重复执行</b>，所以写这个代码<b>有点技巧</b>。这题不能算独立完成，因为<b>我看了评论思路</b>。

<hr>

1582 Special Positions in a Binary Matrix

题意：给定m x n矩阵mat，如果`mat[i][j]=1`，而且它是i行、j列唯一的1，则称为<b>特别位置</b>。求特别位置的个数。

难度：easy

解法：水题，统计`row_cnt[m]`和`col_cnt[n]`即可。

<hr>

1583 Count Unhappy Friends

题意：有n个人，n是偶数。每个人对其他`n-1`人有偏好`preferences[i]`。这个偏好的<b>先后顺序</b>代表偏好程度。现在给定`n/2`组配对，把这n个人结伴。如果存在`(x,y)+(u,v)`，且x更喜欢u，u更喜欢x，则<b>x、u不开心</b>。请统计出<b>不开心的人数</b>。

难度：medium

解法：这题<b>有点费解</b>，指的是<b>配对配错了</b>，导致不开心。那是不是直接枚举`O(n^2)`次？好像可以，那我们就按照<b>题目给定的规则</b>去做。比如检查`(x,y)`，那么我先检查其他的y1，看有没有更偏好的。如果有，则检查y1的配对`(y1,x1)`，看看y1是不是<b>更偏好x，而不是x1</b>。如果<b>双向检查</b>都符合题目规则，则说明<b>x不开心</b>。对于y，则按`(y,x)`的顺序检查一遍，<b>反之亦然</b>。总代价`O(n^2)`。

<hr>

1584 Min Cost to Connect All Points

题意：给定二维平面一些点`(xi,yi)`，距离计算按<b>曼哈顿距离</b>。求出<b>最小生成树</b>的权值。

难度：medium

解法：题目没说MST，但<b>这个就是MST</b>。n个点，<b>`C(n,2)`条边</b>，每条边的距离，你可以用曼哈顿距离计算。然后执行<b>Kruskal算法</b>即可。总代价`O(n^2logn)`。

<hr>

1588 Sum of All Odd Length Subarrays

题意：给定数组nums，请求出所有长度为奇数的子数组之和。尝试用`O(n)`代价完成。

难度：easy

解法：要`O(n)`代价也不难，对于`nums[i]`，考虑它<b>被加了几次</b>。i的左边有x个，右边有y个，其中`x=i+1,y=n-i`。则`nums[i]`总共被加了`cc[i]=(x//2)*(y//2)+((x+1)//2)*((y+1)//2)`次。总和就是`sum(cc[i]*nums[i])`。

<hr>

1592 Rearrange Spaces Between Words

题意：给定英文句子，把空格收集起来，<b>尽量平均分配</b>，放到<b>单词之间</b>。如果有多余空格，按照<b>靠后多一个</b>的原则分布。

难度：easy

解法：水题。

<hr>

1593 Split a String Into the Max Number of Unique Substrings

题意：给定字符串s，将其<b>划分</b>为几个子串，使得所有子串<b>都不同</b>。求<b>最大的划分个数</b>。

难度：medium

解法：<b>数据范围</b>暗示你直接搜，这个确实没法用DP处理。<b>暴力搜吧。</b>

<hr>

1598 Crawler Log Folder

题意：有一些目录访问记录logs，包括“../”、“./”、“x/”三种，代表上一层、当前位置、x子目录。请求出执行logs所有记录后的<b>目录深度</b>。以“/”根目录为0深度。

难度：easy

解法：水题。

<hr>

1600 Throne Inheritance

题意：皇室的血脉和继承顺序，有出生`birth()`，有去世`death()`。按照<b>先父子、后兄弟姐妹</b>的顺序，输出继承顺序。如果成员去世，则从继承顺序中去掉。

难度：medium

解法：题目描述非常啰嗦难懂，但例子一看就明白了，<b>前序遍历</b>。对于<b>成员去世，不能删除</b>对应的节点。只做一下<b>标记</b>，不放入继承顺序即可。可以用`dict[str,list[str]]`的方式来保存<b>树形结构</b>。加一个<b>live标记</b>，用于判断成员是否还活着。
