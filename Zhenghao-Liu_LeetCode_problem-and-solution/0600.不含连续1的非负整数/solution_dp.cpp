#include <bits/stdc++.h>
#include <vector>
#include <iostream>
#include <string>
#include <map>
#include <set>
#include <unordered_map>
#include <algorithm>
using namespace std;

/*
* 先考虑最基本的情况：n位二进制数时，不包括连续的1的个数，设为dp
  那么考虑当前有i位时，
  1. 对于i-1位，只要在末尾加上一个0，就一定没有连续的1
  但是对于i-1位，不能简单的加上1，因为不能去到i-1位的最地位是0还是1，
  2. 所以应该考虑i-2位，在末尾加上01，就一定没有连续的1
  所以dp[i]=dp[i-1]+dp[i-2]
  初始化dp[0]=1，因为数位共0位时只有1种可能即""（空），只有这一种情况，同时也为了dp的正确性
* 再考虑本题，因为是小于等于n的非负整数，所以在二进制下应该从高位到低位去遍历num
  倘若遇到0，不用理，因为是小于等于，在遇到1时候变小即可
  倘若遇到1，因为小于等于，可以先考虑该位为0的情况，再考虑为1的情况，
  但是注意遇到连1的可能，这时候连1中第二个遍历到的1只可能考虑0的情况，不可能考虑1的可能，所以这时候0已经把全部可能性考虑完了，所以只用考虑该位为0情况，就可以break了
* eg1:num=1010100B
  现在求[0000000,1010100]范围内不含连续1的个数
  1. 遇到第[6]=1，则将该位变成0，即考虑[0000000,0111111]的个数即dp[6]
     那么现在范围变成[1000000,1010100]
  2. 遇到第[4]=1，则将该位变成0，即考虑[1000000,1001111]的个数即dp[4]
     那么现在范围变成[1010000,1010100]
  3. 遇到第[2]=1，则将该位变成0，即考虑[1010000,1010011]的个数即dp[2]
     那么现在范围变成[1010100,1010100]即只有num了
  4. 可以借助一个小结论(num&(num>>1))==0判断单个数是否有连续的1出现
* 但是上述例子没有出现连1的情况
  eg2:num=1011010B
  现在求[0000000,1011010]范围内不包含连续1的个数
  1. 遇到[6]=1，则将该位变成0，即考虑[0000000,0111111]的个数即dp[6]
     那么现在范围变成[1000000,1011010]
  2. 遇到[4]=1，则将该位变成0，即考虑[1000000,1001111]的个数即dp[4]
     那么现在范围变成[1010000,1011010]
  3. 遇到[5]=1，则将该位变成0，即考虑[1010000,1010111]的个数即dp[3]
     那么现在范围变成[1011000,1011010]
     但是这个范围已经有连续的1了，所以不用再遍历下去，可直接break
  4. 最后num因为本身有连续的1，自然也是通不过(num&(num>>1))==0
*/
const int bit_size_int=32;
class Solution {
public:
    int findIntegers(int num) {
        vector<int> dp(bit_size_int);
        dp.at(0)=1;
        dp.at(1)=2;
        for (int i=2;i<bit_size_int;++i)
            dp.at(i)=dp.at(i-1)+dp.at(i-2);
        int ans=0;
        bitset<bit_size_int> binary_num(num);
        for (int i=bit_size_int-1;i>=0;--i)
        {
            if (binary_num[i]==1)
            {
                ans+=dp.at(i);
                if (i!=bit_size_int-1 && binary_num[i+1]==1)
                    break;
            }
        }
        if ((num&(num>>1))==0)
            ++ans;
        return ans;
    }
};
