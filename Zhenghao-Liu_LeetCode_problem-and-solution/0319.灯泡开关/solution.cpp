#include <bits/stdc++.h>
#include <vector>
#include <iostream>
#include <string>
#include <map>
#include <set>
#include <unordered_map>
#include <algorithm>
using namespace std;

/*
题目讲的有点繁琐，记住一开始n个灯泡全都是关闭，然后操作n论，第i论隔i个灯泡就翻转一下

假设n=8 开始都是关闭状态
第八个灯泡：第一轮，第二轮，第四轮，第八轮，会翻转->关
第七个灯泡：第一轮，第七轮，会翻转->关
第六个灯泡：第一轮，第二轮，第三轮，第六轮，会翻转->关
第五个灯泡：第一轮，第五轮，会翻转->关
第四个灯泡：第一轮，第二轮，第四轮，会翻转->开
第三个灯泡：第一轮，第三轮，会翻转->关
第二个灯泡：第一轮，第二轮，会翻转->关
第一个灯泡，第一轮，会翻转->开

所以结果是2 其实无非就是

8=1*8=2*4
7=1*7
6=1*6=2*3
5=1*5
4=1*4=2*2 就是因为相乘的两个因数是同一个数字，导致比别的少翻转一次(或者是多一次)，就有最开始的关闭变成了开启
3=1*3
2=1*2
1=1*1 就是因为相乘两个因数是同一个数字，所以少翻转一次，就有初始的关闭，变成了开启

所以其实就是找那些一个数划分成两数相乘，其对应的两个因数可以是同一个数的情况，也就是平方数
*/
class Solution {
public:
    int bulbSwitch(int n) {
        return sqrt(n);
    }
};
