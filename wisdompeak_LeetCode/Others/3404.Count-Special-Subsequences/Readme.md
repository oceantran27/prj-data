### 3404.Count-Special-Subsequences

考虑n的数量级，我们只能支持两重循环。

如果我们遍历p和r，那么如何能只用o(1)计算在(p,r)和(r,n)里相等乘积的pairs呢？这两段区间都是动态的，没法预处理，这个思路很难进行下去。

如果我们遍历p和q，那么我们需要用o(1)计算在(q,n)里找到两处r和s，使得nums[s]/nums[r]等于给定的ratio（即nums[p]/nums[q]）。此时发现我们需要寻找的pairs集中在数组的右半边，这就提示我们可以将数组左边和右边分别进行预处理，可以用两次o(n^2)的时间求出所有的pairs的ratio，再按照ratio的数值作为hash key进行统计。

那么如何进行统计呢？我们顺着这个思路继续想下去。为了方便，假设我们用两重循环枚举r和s。随着r的移动，我们对于p/q的考察范围会相应地扩大，即[0,r-2]。我们想知道，在这个区间里有多少pairs的ratio等于nums[s]/nums[r]？注意到我们的考察区间有个上限，这说明了我们在预处理所有pairs的时候，除了按照ratio的值进行hash存放，还需要记录位置。记录什么位置呢？按q的位置进行记录就行了，因为p肯定小于q，故只要记录一个q，那么说明必然有一个相应合法的p存在。

更具体的，假设我们有很多对ratio相同的pairs，例如(1,3),(2,5),(2,8),(3,8),(4,8),(5,9),(6,9)，我们只需要存下`Map[ratio]={3,5,8,8,8,9,9}`. 当r=10时，我们知道q的上界就是8，故只需要在这个数组里寻找小于等于8的个数，这里有5个，就说明有5个pairs可以作为(p,q)，与当前枚举的（r,s）进行配对。

由此我们可以用两重循环枚举r与s，配合这种巧妙的hash记录，用`n^2*log(n)`的时间求解。
