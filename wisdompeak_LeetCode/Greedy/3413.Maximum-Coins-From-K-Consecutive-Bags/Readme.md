### 3413.Maximum-Coins-From-K-Consecutive-Bags

此题和2271.Maximum-White-Tiles-Covered-by-a-Carpet的思路类似。

对于长度为k的跨度，如果其一个端点没有落在任何区间，那么显然是不划算的。我们必然有更优的策略：平移这段跨度直至一端接触到某个区间的边缘，这样可以在另一端覆盖到更多的有效区域得到更大的价值。注意“某个区间的端点”可以是左端点，也可以是右端点。

再考虑，对于长度为k的跨度，如果其两个端点分别都落在了区间A和区间B内，那么同样也是不划算的。只要区间A和B的价值密度不一样，那么我们必然能找到更优的解，即朝价值密度更高的那个方向平移即可。平移的最终结果是：完全离开价值密度低的区间（如果另一端依然在价值密度高的区间的话），或者触碰到价值密度高的区间的边缘。

所以上述的结论就是，最优解的情况，必然发生在所选跨度恰好触碰在某个区间边缘的时候。所以我们分两种情况。首先，从左往右遍历每个区间的左边缘，当做是所选跨度k的左边界，然后可以确定右边界的位置，这样就计算总价值；随着对左边界的挨个尝试，右边界也是单调移动的。所以这是一个典型的双指针。然后，反过来，从右往左遍历每个区间的右边缘，当做是所选跨度的右边界，然后可以确定左边界的位置，这样就计算总价值；随着对右边界的挨个尝试，左边界也是单调移动的。

对于第二次遍历，我们可以重复利用第一次遍历的函数。只要将每个区间的左右端点完全颠倒即可。即原区间范围是[a,b]，那么我们构造一个新的区间范围[-b,-a]。这样我们依然可以重复利用从左往右遍历的代码，本质上实现了从右往左的遍历。
