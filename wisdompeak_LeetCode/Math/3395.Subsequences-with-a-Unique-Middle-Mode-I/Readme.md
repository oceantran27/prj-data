### 3395.Subsequences-with-a-Unique-Middle-Mode-I

所有任取5个元素的子序列有comb(n,5)个。我们枚举nums[i]=a为中间元素，考虑计算不符合条件的子序列的个数。

如果a出现了3次或以上，那么该序列必然是符合条件的，不用考虑。

如果a只出现了1次，那么该序列必然不符合条件。这样的子序列有多少个呢？只需要在左区间里任选两个非a的元素，在右区间里任选两个非a的元素。故可构造这样的子序列的个数是`comb(i-left[a],2) * comb(n-i-1-right[a], 2)`。其中left表示统计i左边的元素的频次hash，right表示统计i右边的元素的频次hash。

如果a出现了2次，那么必然有一种元素b出现了两次或三次，才能是不符合条件的子序列。我们可以枚举b，并分为三种情况：
1. b出现了两次，且两次都出现在同一侧（假设是左边），那么右边必须要出现另一个a，以及一个非a也非b的元素（假设是c）。故写为`b b a a c`的类型。这样的概率是
```
comb(left[a],2) * (right[a],1) * (n-i-1-right[a]-right[b], 1)
```
类似的，如果两个b都在另一侧，只需将上面的left和right相反即可。
```
comb(right[a],2) * (left[a],1) * (i-left[a]-left[b], 1)
```

2. b出现了两次，且出现在两侧，那么nums[i]的左右两边分别需要再出现另一个a，以及一个非a也非b的元素（假设是c）。故写为`b a a b c`的类型。这样的概率是
```
comb(left[a],1) * (left[b],1) * right([b],1) * (n-i-1-right[a]-right[b], 1)
```
或者反过来
```
comb(right[a],1) * (right[b],1) * left([b],1) * (i-left[a]-left[b], 1)
```

3. b出现了三次，占据了除两个a之外的全部位置。故写为`b b a a b`的类型。这样的概率是
```
comb(left[b],2) * (right[b],1) * right([a],1)
```
或者反过来
```
comb(right[b],2) * (left[b],1) * left([a],1)
```

上述算法用了两重循环枚举a和b。另外，因为n只有1000，我们可以用n^2时间（或者只需要n*5）提前计算好所有1000以内的组合数。所以总的时间复杂度是n^2.
