[题解地址](https://bitbrave.github.io/2020/03/14/LeetCode(621.%20Task%20Scheduler)%E9%A2%98%E8%A7%A3/)

### 解题思路
Hard

给定由大写字母标的的任务列表，和一个表示间隔的值n。现在有一个电脑，可以在一个间隔的时间内完成一个任务，但是相同的任务必须隔至少n个间隔才能再次运行，每个间隔内，电脑可以选择运行任务，或者空闲。

请问完成所有任务需要的最小间隔数是多少?

我所能想到的解法是贪心：

统计相同任务的个数，然后将任务按照任务数降序排序。然后从前到后遍历。那么第一个任务的A个数就决定了最少的间隔数是肯定大于等于，（A-1）* n + A的。那么我们可以默认空出来了（A-1）* n的间隔，后续的任务可以在这些间隔内完成，这样就不用增加新的间隔，间隔不够就再挨着慢慢增加。而贪心策略就是，我们，每次在空闲间隔内增加的方式是：以第一个任务A的排布为边界，在每个A之间分别加上当前任务，这样肯定满足条件，同时，每次添加都是沿着上一次任务结束的位置添加，如果没有空格了，还是在A的任务之间插入新的即可，在这个过程中计算增加的间隔。如果加入的任务B的个数等于A，那么除了A之间的空闲全部占掉一个之外，在最后A的外面也要占掉一个，会增加一个新的间隔。

如何证明这种算法是正确的呢？我并没有想出来很形式化的语言，但是算法的过程中，每一步都尽可能不增加新的间隔，直到最后，任何最优的方案最后都可以转化为这种算法得到的答案。

### 时空复杂度
代码如下，时间上，统计任务数$O(N)$，排序因为是26个 字母固定的，为$O(1)$。空间上，$O(1)$。