/* Notes:
 *
 */

#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>

#include "test.h"
using namespace std;

class Solution {
    /* record[i] corresponds all combinations of well-formed parentheses
     * generated by i pairs of parentheses.
     */
    vector<vector<string> > record;

    void fill_record(int n){
        record.resize(n + 1);

        vector<string> tmp;

        tmp.push_back("");
        record[0] = tmp;

        tmp[0] = "()";
        record[1] = tmp;

        for(int i = 2; i <= n; i ++){
            vector<int> tmp;
            record[i] = do_generate_parenthesis(tmp, i);
        }
    }

    vector<string> get_parentheses(int n){ 
        /* each element will be a part, so they are all surrounded by a pair of
         * parentheses, and the middle will be record[n - 1].
         */
        vector<string> parentheses = record[n - 1];

        for(size_t i = 0; i < parentheses.size(); i ++){
            parentheses[i] = "(" + parentheses[i] + ")";
        }

        return parentheses;
    }

    /* If there is k1 combinations and k2 combinations, there will be k1 * k2 
     * combinations for the result.  
     */
    vector<string> multiply(const vector<string> &v1, const vector<string> &v2){
        vector<string> ret;

        for(size_t i = 0; i < v1.size(); i ++){
            for(size_t j = 0; j < v2.size(); j ++){
                ret.push_back(v1[i] + v2[j]);
            }
        }

        return ret;
    }

    vector<string> do_generate_parenthesis(vector<int> pre_allocate, int n){
        vector<string> parentheses;

        if(n <= 0){
            parentheses = record[0];
            for(size_t i = 0; i < pre_allocate.size(); i ++){
                parentheses = multiply(parentheses, get_parentheses(pre_allocate[i]));
            }

            return parentheses;
        }

        pre_allocate.push_back(0);
        int end = pre_allocate.size() - 1;
        /* Divide n pairs of parentheses to several parts, and find all possible
         * allocation to each parts.
         */
        for(int i = 1; i <= n; i ++){
             pre_allocate[end] = i; // allocate i pairs of parentheses to this part.

             vector<string> tmp = do_generate_parenthesis(pre_allocate, n - i);
             parentheses.insert(parentheses.end(), tmp.begin(), tmp.end());
        }

        return parentheses;
    }

public:
    vector<string> generateParenthesis(int n) {
        /* I divided parentheses to several parts which are surrounded by 
         * parentheses '()' and do not overlap with each other, e.g. 
         * "()(())(()())" contains three parts: "()", "(())" and "(()())".
         * Add I could also divide all combinations of well-formed parentheses
         * generated by n pairs of parentheses to several parts. then the 
         * answer to the question becomes finding all possible combinations of
         * parts and the pairs number of parentheses belongs to each parts, for
         * each part, they are surrounded by a pair of parentheses "()", like 
         * "(...)", the middle of the parentheses are all combinations of 
         * well-formed parentheses generated by k pairs of parentheses(suppose
         * there are k pairs in this part).
         */
        record.clear();
        fill_record(n);

        return record[n];
    }
};

/*
class Solution {
    string add_left(string s){
        return "()" + s;    
    }

    string add_right(string s){
        return s + "()";    
    }

    string add_out(string s){
        return "(" + s + ")";    
    }

    void add_and_record(vector<string> &v, const string &s, set<string> &record){
        if(record.count(s))
            return;

        record.insert(s);
        v.push_back(s);
    }

public:
    vector<string> generateParenthesis(int n) {
        vector<string> parenthesis; 
        if(n <= 0)
            return parenthesis;

        parenthesis.push_back("()");
        
        for(int i = 1; i < n; i ++){
            vector<string> tmp_parenthesis;
            set<string> record;

            for(size_t j = 0; j < parenthesis.size(); j ++){
                string s = parenthesis[j];
                
                add_and_record(tmp_parenthesis, add_left(s), record);
                add_and_record(tmp_parenthesis, add_right(s), record);
                add_and_record(tmp_parenthesis, add_out(s), record);
            }

            parenthesis.swap(tmp_parenthesis);
        }

        return parenthesis;
    }
};
*/
